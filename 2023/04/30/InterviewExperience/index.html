<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="Aria"><meta name="copyright" content="Aria"><meta name="generator" content="Hexo 5.4.2"><meta name="theme" content="hexo-theme-yun"><title>Interview Experience | Aria's NoteBook</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.4.1/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/svg+xml" href="/_myBlog/yun.svg"><link rel="mask-icon" href="/_myBlog/yun.svg" color="#0078E7"><link rel="preload" href="/_myBlog/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/_myBlog/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"aria-geng.github.io","root":"/_myBlog/","title":"云游君的小站","version":"1.10.9","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"fireworks":{"colors":null},"vendors":{"host":"https://fastly.jsdelivr.net/npm/","darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/_myBlog/css/hexo-theme-yun.css"><script src="/_myBlog/js/hexo-theme-yun.js" type="module"></script><meta name="description" content="Quick StartComputer Network301 moved permanently，永久性重定向，表示资源已被分配了新的 URL302 found，临时性重定向，表示资源临时被分配了新的 URL303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况307 temp">
<meta property="og:type" content="article">
<meta property="og:title" content="Interview Experience">
<meta property="og:url" content="https://aria-geng.github.io/_myBlog/2023/04/30/InterviewExperience/index.html">
<meta property="og:site_name" content="Aria&#39;s NoteBook">
<meta property="og:description" content="Quick StartComputer Network301 moved permanently，永久性重定向，表示资源已被分配了新的 URL302 found，临时性重定向，表示资源临时被分配了新的 URL303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况307 temp">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-ba440cf5ee0d73bf605fb3a6aeee49f7_720w.webp">
<meta property="article:published_time" content="2023-04-30T10:10:33.917Z">
<meta property="article:modified_time" content="2023-04-30T10:56:27.739Z">
<meta property="article:author" content="Aria">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic4.zhimg.com/80/v2-ba440cf5ee0d73bf605fb3a6aeee49f7_720w.webp"><script>(function() {
  if (CONFIG.mode !== 'auto') return
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/_myBlog/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/_myBlog/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/_myBlog/about/" title="Aria"><img width="96" loading="lazy" src="/_myBlog/yun.png" alt="Aria"></a><div class="site-author-name"><a href="/_myBlog/about/">Aria</a></div><span class="site-name">Aria's NoteBook</span><sub class="site-subtitle"></sub><div class="site-description"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/_myBlog/" title="Home"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/_myBlog/archives/" title="Archives"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">1</span></a></div><div class="site-state-item"><a href="/_myBlog/categories/" title="Categories"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">0</span></a></div><div class="site-state-item"><a href="/_myBlog/tags/" title="Tags"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">0</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:settings-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/_myBlog/links/" title="我的小伙伴们" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:genderless-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Quick-Start"><span class="toc-number">1.</span> <span class="toc-text">Quick Start</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Computer-Network"><span class="toc-number"></span> <span class="toc-text">Computer Network</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OSI-%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%AF%8F%E2%BC%80%E5%B1%82%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">0.0.1.</span> <span class="toc-text">OSI 七层模型是什么？每⼀层的作用是什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-IP-%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%AF%8F%E4%B8%80%E5%B1%82%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">0.1.</span> <span class="toc-text">TCP&#x2F;IP 四层模型是什么？每一层的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E4%B8%8E-UDP-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">0.2.</span> <span class="toc-text">TCP 与 UDP 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%89%E6%8B%A9-TCP-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%89-UDP"><span class="toc-number">0.3.</span> <span class="toc-text">什么时候选择 TCP,什么时候选 UDP?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-TCP-%E7%9A%84%E5%8D%8F%E8%AE%AE%E6%9C%89%E5%93%AA%E4%BA%9B-%E4%BD%BF%E7%94%A8-UDP-%E7%9A%84%E5%8D%8F%E8%AE%AE%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">0.4.</span> <span class="toc-text">使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E3%80%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">0.5.</span> <span class="toc-text">TCP建立连接、三次握手过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E6%88%96%E5%9B%9B%E6%AC%A1%EF%BC%9F"><span class="toc-number">0.6.</span> <span class="toc-text">TCP 为什么是三次握手，而不是两次或四次？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BC%A0%E5%9B%9E%E4%BA%86ACK%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E4%BC%A0%E5%9B%9ESYN%EF%BC%9F"><span class="toc-number">0.7.</span> <span class="toc-text">第2次握手传回了ACK，为什么还要传回SYN？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5-TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">0.8.</span> <span class="toc-text">断开连接-TCP 四次挥手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F"><span class="toc-number">0.9.</span> <span class="toc-text">为什么要四次挥手？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%8A%8A%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E7%9A%84-ACK-%E5%92%8C-FIN-%E5%90%88%E5%B9%B6%E8%B5%B7%E6%9D%A5%EF%BC%8C%E5%8F%98%E6%88%90%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F"><span class="toc-number">0.10.</span> <span class="toc-text">为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%97%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84-ACK-%E6%B2%A1%E6%9C%89%E9%80%81%E8%BE%BE%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%8C%E4%BC%9A%E6%80%8E%E6%A0%B7%EF%BC%9F"><span class="toc-number">0.11.</span> <span class="toc-text">如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%852MSL%EF%BC%88%E6%8A%A5%E6%96%87%E6%AE%B5%E6%9C%80%E9%95%BF%E5%AF%BF%E5%91%BD%EF%BC%89%E6%97%B6%E9%97%B4%E5%90%8E%E6%89%8D%E8%BF%9B%E5%85%A5-CLOSED-%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">0.12.</span> <span class="toc-text">为什么第四次挥手客户端需要等待2MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%EF%BC%9F"><span class="toc-number">0.13.</span> <span class="toc-text">TCP 如何保证传输的可靠性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%EF%BC%9F%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">0.14.</span> <span class="toc-text">TCP 如何实现流量控制？（滑动窗口）为什么需要流量控制?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">0.15.</span> <span class="toc-text">TCP 的拥塞控制是怎么实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ARQ-%E5%8D%8F%E8%AE%AE%E4%BA%86%E8%A7%A3%E5%90%97"><span class="toc-number">0.16.</span> <span class="toc-text">ARQ 协议了解吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E8%BE%93%E5%85%A5URL-%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">0.17.</span> <span class="toc-text">从输入URL 到页面展示到底发生了什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">0.18.</span> <span class="toc-text">HTTP 状态码有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E5%92%8C-HTTPS-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">0.19.</span> <span class="toc-text">HTTP 和 HTTPS 区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-1-0-%E5%92%8C-HTTP-1-1-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">0.20.</span> <span class="toc-text">HTTP 1.0 和 HTTP 1.1 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E6%98%AF%E4%B8%8D%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81%E7%9A%84%E5%8D%8F%E8%AE%AE-%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E7%94%A8%E6%88%B7%E7%8A%B6%E6%80%81"><span class="toc-number">0.21.</span> <span class="toc-text">HTTP 是不保存状态的协议, 如何保存用户状态?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#URI-%E5%92%8C-URL-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">0.22.</span> <span class="toc-text">URI 和 URL 的区别是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GET%E5%92%8CPOST%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">0.23.</span> <span class="toc-text">GET和POST请求的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">0.24.</span> <span class="toc-text">TCP粘包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E8%BF%9E%E6%8E%A5%E3%80%81%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="toc-number">0.25.</span> <span class="toc-text">长连接、短连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0SYN%E6%94%BB%E5%87%BB"><span class="toc-number">0.26.</span> <span class="toc-text">简述SYN攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">0.27.</span> <span class="toc-text">转发和重定向的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0http2-0%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">0.28.</span> <span class="toc-text">简述http2.0的改进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Get%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E6%9C%89%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6%E5%90%97"><span class="toc-number">0.29.</span> <span class="toc-text">Get方法参数有大小限制吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88TIME-WAIT%E7%8A%B6%E6%80%81%E9%9C%80%E8%A6%81%E7%BB%8F%E8%BF%872MSL-%E6%9C%80%E5%A4%A7%E6%8A%A5%E6%96%87%E6%AE%B5%E7%94%9F%E5%AD%98%E6%97%B6%E9%97%B4-%E6%89%8D%E8%83%BD%E8%BF%94%E5%9B%9E%E5%88%B0CLOSE%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">0.30.</span> <span class="toc-text">为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AF%B9http1%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">0.31.</span> <span class="toc-text">如何对http1进行优化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLS-%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-HTTP-%E7%9A%84%E2%BB%9B%E9%99%A9%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">0.32.</span> <span class="toc-text">TLS 协议是如何解决 HTTP 的⻛险的呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http2%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">0.33.</span> <span class="toc-text">http2优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http2-%E7%BC%BA%E7%82%B9%E5%92%8Chttp3-%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">0.34.</span> <span class="toc-text">http2 缺点和http3 的改进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-SYN-%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D-SYN-%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-number">0.35.</span> <span class="toc-text">什么是 SYN 攻击？如何避免 SYN 攻击？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-TIME-WAIT-%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">0.36.</span> <span class="toc-text">为什么需要 TIME_WAIT 状态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TIME-WAIT-%E8%BF%87%E5%A4%9A%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3%EF%BC%9F"><span class="toc-number">0.37.</span> <span class="toc-text">TIME_WAIT 过多有什么危害？</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="https://aria-geng.github.io/_myBlog/_myBlog/2023/04/30/InterviewExperience/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Aria"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Aria's NoteBook"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Interview Experience</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="Created: 2023-04-30 18:10:33" itemprop="dateCreated datePublished" datetime="2023-04-30T18:10:33+08:00">2023-04-30</time></div><div class="post-classify"></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h1 id="Computer-Network"><a href="#Computer-Network" class="headerlink" title="Computer Network"></a>Computer Network</h1><p>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL302 found，临时性重定向，表示资源临时被分配了新的 URL303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况307 temporary redirect，临时重定向，和302含义相同</p>
<h4 id="OSI-七层模型是什么？每⼀层的作用是什么？"><a href="#OSI-七层模型是什么？每⼀层的作用是什么？" class="headerlink" title="OSI 七层模型是什么？每⼀层的作用是什么？"></a>OSI 七层模型是什么？每⼀层的作用是什么？</h4><ul>
<li>OSI 七层模型 是国际标准化组织提出⼀个网络分层模型，包括 物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</li>
<li>每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到那里。</li>
</ul>
<h3 id="TCP-IP-四层模型是什么？每一层的作用是什么？"><a href="#TCP-IP-四层模型是什么？每一层的作用是什么？" class="headerlink" title="TCP/IP 四层模型是什么？每一层的作用是什么？"></a>TCP/IP 四层模型是什么？每一层的作用是什么？</h3><ul>
<li>TCP/IP 四层模型 是目前被广泛采用的一种模型，是 OSI 七层模型的精简版本，包括应用层，传输层，网络层，网络接口层。<ul>
<li>应用层：提供两个终端设备应用程序之间信息交换的服务<ul>
<li>定义了<ul>
<li>信息交换的格式；</li>
<li>网络通信规则，如支持 Web 应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。</li>
</ul>
</li>
</ul>
</li>
<li>传输层：负责向两台终端设备进程之间的通信提供通用的数据传输服务。<ul>
<li>主要使用以下两种协议：<ul>
<li>TCP提供面向连接的，可靠的数据传输服务。</li>
<li>UDP提供无连接的，尽最大努力的数据传输服务 （不保证数据传输的可靠性）。</li>
</ul>
</li>
</ul>
</li>
<li>网络层：为分组交换网上的不同主机提供通信服务。<ul>
<li>发送数据把传输层产生的 报文段 或 用户数据报 封装 成 <strong>分组</strong> 和 包 进行传送。</li>
<li>常见的协议有IP、ARP、NAT协议。</li>
</ul>
</li>
<li>网络接口层：数据链路层和物理层的合体。<ul>
<li>数据链路层：将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。<ul>
<li>每⼀帧包括数据和必要的控制信息：如同步信息，地址信息，差错控制 等。</li>
</ul>
</li>
<li>物理层：实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="TCP-与-UDP-的区别"><a href="#TCP-与-UDP-的区别" class="headerlink" title="TCP 与 UDP 的区别"></a>TCP 与 UDP 的区别</h3><ol>
<li>UDP ：传送数据之前<strong>不需</strong>要先建立连接； TCP：提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后释放连接。</li>
<li>TCP：提供可靠的传输服务，在传递数据前有三次握手建立连接，而且在数据传递时，有确认、窗⼝、重传、拥塞控制机制，传输的数据无差错、不丢失、不重复、并且按序到达； UDP：不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。</li>
<li>TCP：传输有状态的，会去记录自己发送消息的状态：比如消息是否发送了、是否被接收了，需要维持复杂的连接状态表； UDP：无状态服务，不管发出去之后的事情。</li>
<li>传输效率：TCP传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</li>
<li>传输形式：<ul>
<li>TCP 面向字节流</li>
<li>UDP面向报文的</li>
</ul>
</li>
<li>首部开销：<ul>
<li>TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要⼤。</li>
</ul>
</li>
<li>TCP 只⽀持点对点通信； UDP ⽀持⼀对⼀、⼀对多、多对⼀、多对 多。</li>
</ol>
<h3 id="什么时候选择-TCP-什么时候选-UDP"><a href="#什么时候选择-TCP-什么时候选-UDP" class="headerlink" title="什么时候选择 TCP,什么时候选 UDP?"></a>什么时候选择 TCP,什么时候选 UDP?</h3><ul>
<li>UDP：即时通信，如语音、 视频 、直播。对传输数据的准确性要求不是特别高，比如看视频即使少个一两帧，实际感觉区别也不大。</li>
<li>TCP：对传输准确性要求特别高的场景，比如文件传输、发送和接收邮件、远程登录等。</li>
</ul>
<h3 id="使用-TCP-的协议有哪些-使用-UDP-的协议有哪些"><a href="#使用-TCP-的协议有哪些-使用-UDP-的协议有哪些" class="headerlink" title="使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?"></a>使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?</h3><ul>
<li>运行于 TCP 协议之上的协议<ul>
<li>HTTP 协议 ：超⽂本传输协议，主要为 Web 浏览器之间的通信设计。浏览器网页通过 HTTP 请求加载。</li>
<li>HTTPS 协议 ：更安全的超文本传输协议</li>
<li>FTP 协议：文件传输协议提供文件传输服务,屏蔽操作系统和文件存储方式。</li>
<li>SMTP 协议：简单邮件传输协议，发送电子邮件。</li>
<li>SSH 协议：专为远程登录会话和其他网络服务提供安全性的协议，有效防止远程管理过程中的信息泄露。</li>
</ul>
</li>
<li>运行于 UDP 协议之上的协议 ：<ul>
<li>DNS：域名系统，同时支持 UDP 和 TCP 协议，将人类可读的域名 (<a target="_blank" rel="noopener" href="http://如www.baidu.com/">如www.baidu.com</a>) 转换为机器可读的 IP 地址 (如220.181.38.148)。</li>
</ul>
</li>
</ul>
<h3 id="TCP建立连接、三次握手过程"><a href="#TCP建立连接、三次握手过程" class="headerlink" title="TCP建立连接、三次握手过程"></a>TCP建立连接、三次握手过程</h3><p>（目的：建立可靠的通信信道，双方确认发送与接收正常）</p>
<ol>
<li>客户端——-&gt;SYN标志的数据包——-&gt;服务端(然后SYN_SEND状态，等待服务器确认)；</li>
<li>服务端——-&gt;SYN+ACK标志的数据包——-客户端（SYN_RECV）；</li>
<li>客户端——-&gt;ACK(ACK=y+1)标志的数据包——-&gt;服务端，客户端和服务器都进入ESTABLISHED 状态。 （如果客户端发给服务器的同步信号丢了，客户端不会重传，但是服务器没有收到客户端的ACK会超时重传自己的SYN信号，直到收到客户端的ACK为止）</li>
</ol>
<h3 id="TCP-为什么是三次握手，而不是两次或四次？"><a href="#TCP-为什么是三次握手，而不是两次或四次？" class="headerlink" title="TCP 为什么是三次握手，而不是两次或四次？"></a>TCP 为什么是三次握手，而不是两次或四次？</h3><p>TCP连接握手，其实是传输数据原点的序列号</p>
<ul>
<li>四次握手过程<ol>
<li></li>
<li>服务器确认收到客户端的同步信号，并记录客户端的ISN到本地，命名为服务器的ACK</li>
<li>服务器发送同步信号SYN和服务器的初始序列号</li>
<li></li>
</ol>
  2和3可以合并，只需要三次握手，提高连接的速度与效率。</li>
<li>两次握手：去掉最后一次握手，客户端和服务器就客户端的初始序列号达成一致，但是服务器不知道客户端是否收到自己的同步信号</li>
</ul>
<h3 id="第2次握手传回了ACK，为什么还要传回SYN？"><a href="#第2次握手传回了ACK，为什么还要传回SYN？" class="headerlink" title="第2次握手传回了ACK，为什么还要传回SYN？"></a>第2次握手传回了ACK，为什么还要传回SYN？</h3><ul>
<li>服务端传回发送端所发送的 ACK：告诉客户端自己接收到的信息就是客户端所发送的信号，从客户端到服务端的通信是正常的。</li>
<li>回传 SYN 是为了建立并确认从服务端到客户端的通信。</li>
</ul>
<h3 id="断开连接-TCP-四次挥手"><a href="#断开连接-TCP-四次挥手" class="headerlink" title="断开连接-TCP 四次挥手"></a>断开连接-TCP 四次挥手</h3><ol>
<li>客户端——&gt;FIN（SEQ=X）标志的数据包——-&gt;服务端，关闭客户端到服务器的数据传送,客户端进入 <strong>FIN-WAIT-1</strong> 状态。</li>
<li>服务器收到这个 FIN（SEQ=X） 标志的数据包，发送一个 ACK （SEQ=X+1）标志的数据包到客户端 。然后服务器进入<strong>CLOSE-WAIT</strong>状态，客户端进入<strong>FIN-WAIT-2</strong>状态。</li>
<li>服务端关闭与客户端的连接并发送一个 FIN (SEQ=y) 标志的数据包到客户端请求关闭连接，然后，服务端进入<strong>LAST-ACK</strong>状态。</li>
<li>客户端发送 ACK (SEQ=y+1)标志的数据包到服务端并且进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (SEQ=y+1)标志的数据包后进入 <strong>CLOSE</strong> 状态。此时，如果客户端等待 <strong>2MSL</strong> 时间（2min）后依然没有收到回复，就证明服务端已正常关闭，随后客户端也关闭连接。</li>
</ol>
<p><strong>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</strong></p>
<h3 id="为什么要四次挥手？"><a href="#为什么要四次挥手？" class="headerlink" title="为什么要四次挥手？"></a>为什么要四次挥手？</h3><p>TCP是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p>
<h3 id="为什么不能把服务器发送的-ACK-和-FIN-合并起来，变成三次挥手？"><a href="#为什么不能把服务器发送的-ACK-和-FIN-合并起来，变成三次挥手？" class="headerlink" title="为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？"></a>为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</h3><p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。</p>
<h3 id="如果第二次挥手时服务器的-ACK-没有送达客户端，会怎样？"><a href="#如果第二次挥手时服务器的-ACK-没有送达客户端，会怎样？" class="headerlink" title="如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？"></a>如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</h3><p>客户端没有收到 ACK 确认，会重新发送 FIN 请求。</p>
<h3 id="为什么第四次挥手客户端需要等待2MSL（报文段最长寿命）时间后才进入-CLOSED-状态？"><a href="#为什么第四次挥手客户端需要等待2MSL（报文段最长寿命）时间后才进入-CLOSED-状态？" class="headerlink" title="为什么第四次挥手客户端需要等待2MSL（报文段最长寿命）时间后才进入 CLOSED 状态？"></a>为什么第四次挥手客户端需要等待2MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</h3><ul>
<li>第四次挥手时，客户端发送给服务器的 ACK 有可能丢失；</li>
<li>如果服务端没有收到 ACK 会重发 FIN，如果客户端在 2MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 服务器 没有收到 ACK 而不断重发 FIN。</li>
</ul>
<blockquote>
<p>MSL(Maximum Segment Lifetime) : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，客户端 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。</p>
</blockquote>
<h3 id="TCP-如何保证传输的可靠性？"><a href="#TCP-如何保证传输的可靠性？" class="headerlink" title="TCP 如何保证传输的可靠性？"></a>TCP 如何保证传输的可靠性？</h3><ol>
<li><strong>基于数据快传输</strong> ：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层。</li>
<li><strong>对失序数据包重新排序以及去重</strong>：TCP 给每个包一个序列号，将接收到的数据根据序列号排序，并去掉重复序列号的数据就可以去重。</li>
<li><strong>校验和</strong> : 保持 首部 和 数据的检验和，检测数据在传输过程中的任何变化。如果收到段的 检验和 有差错就丢弃并且不确认收到。</li>
<li><strong>超时重传</strong> : 发送方发送数据后启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回相应确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，对应的数据包就被假设为已丢失并重传。</li>
<li><strong>流量控制</strong> : TCP 连接的每一方都有固定大小的缓冲空间，接收端只允许发送端发送接收端缓冲区能接纳的数据。当来不及处理时提示发送方降低发送的速率，防止包丢失。 TCP 使用的流量控制协议是可变大小的滑动窗口协议。</li>
<li><strong>拥塞控制</strong> : 当网络拥塞时，减少数据的发送。</li>
</ol>
<h3 id="TCP-如何实现流量控制？（滑动窗口）为什么需要流量控制"><a href="#TCP-如何实现流量控制？（滑动窗口）为什么需要流量控制" class="headerlink" title="TCP 如何实现流量控制？（滑动窗口）为什么需要流量控制?"></a>TCP 如何实现流量控制？（滑动窗口）为什么需要流量控制?</h3><p>通信时发送方与接收方的速率不一定相等，发送方的发送速率太快，接收方会处理不过来，把处理不过来的数据存在 <strong>接收缓冲区(Receiving Buffers)</strong> 里。如果缓存区满了发送方还在发数据的话，接收方只能把收到的数据包丢掉。丢包也浪费网络资源</p>
<h3 id="TCP-的拥塞控制是怎么实现的？"><a href="#TCP-的拥塞控制是怎么实现的？" class="headerlink" title="TCP 的拥塞控制是怎么实现的？"></a>TCP 的拥塞控制是怎么实现的？</h3><ul>
<li>拥塞：对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。</li>
<li>TCP 发送方维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量，窗口大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。<ul>
<li><strong>慢开始：</strong> 主机开始发送数据时由小到大逐渐增大发送窗口。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</li>
<li><strong>拥塞避免：</strong> 每经过一个往返时间 RTT 就把发送放的 cwnd 加 1.</li>
<li><strong>快重传与快恢复（FRR）：</strong> 如果接收机接收到一个不按顺序的数据段，会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。<ul>
<li>当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。</li>
<li>当有多个数据信息包在某一段很短的时间内丢失时，不能很有效地工作。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="ARQ-协议了解吗"><a href="#ARQ-协议了解吗" class="headerlink" title="ARQ 协议了解吗?"></a>ARQ 协议了解吗?</h3><ul>
<li><strong>自动重传请求</strong>：数据链路层和传输层的错误纠正协议，使用确认和超时在不可靠服务的基础上实现可靠的信息传输。<ul>
<li>如果发送方在发送后一段时间之内没有收到确认信息（Acknoledgements，就是我们常说的 ACK），会重新发送，直到收到确认或者重试超过一定的次数。</li>
<li>包括停止等待 ARQ 协议和连续 ARQ 协议。<ul>
<li>停止等待 ARQ 协议：每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了超时时间还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</li>
<li>连续 ARQ 协议：发送方维持一个发送窗口，位于发送窗口内的分组可以连续发送出去，不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。<ul>
<li><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失也不必重传。</li>
<li><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="从输入URL-到页面展示到底发生了什么？"><a href="#从输入URL-到页面展示到底发生了什么？" class="headerlink" title="从输入URL 到页面展示到底发生了什么？"></a>从输入URL 到页面展示到底发生了什么？</h3><ol>
<li>DNS 解析</li>
<li>TCP 连接</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<h3 id="HTTP-状态码有哪些？"><a href="#HTTP-状态码有哪些？" class="headerlink" title="HTTP 状态码有哪些？"></a>HTTP 状态码有哪些？</h3><ul>
<li>1xx：消息类，服务器收到请求，需要请求者继续执行操作。</li>
<li>2xx：成功类，请求被成功接受并处理。<ul>
<li>200 OK，表示从客户端发来的请求在服务器端被正确处理</li>
<li>204 No content，表示请求成功，但响应报文不含实体的主体部分</li>
<li>206 Partial Content，进行范围请求</li>
</ul>
</li>
<li>3xx：重定向类，需要进一步操作完成请求。<ul>
<li>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL</li>
<li>302 found，临时性重定向，表示资源临时被分配了新的 URL</li>
<li>303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源</li>
<li>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况</li>
<li>307 temporary redirect，临时重定向，和302含义相同</li>
</ul>
</li>
<li>4xx：客户端错误类，客户端请求出错，服务器无法处理请求。<ul>
<li>400 bad request，请求报文存在语法错误</li>
<li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</li>
<li>403 forbidden，表示对请求资源的访问被服务器拒绝</li>
<li>404 not found，表示在服务器上没有找到请求的资源</li>
</ul>
</li>
<li>5xx/6xx：服务器错误类，服务器处理请求出错。</li>
</ul>
<h3 id="HTTP-和-HTTPS-区别？"><a href="#HTTP-和-HTTPS-区别？" class="headerlink" title="HTTP 和 HTTPS 区别？"></a>HTTP 和 HTTPS 区别？</h3><ul>
<li>端口号 ：HTTP 默认是 80，HTTPS 默认是 443。</li>
<li>URL 前缀 ：HTTP 的 URL 前缀是 http:// ，HTTPS 的 URL 前缀是 https:// 。</li>
<li>安全性和资源消耗：<ul>
<li>HTTP 协议运行在 TCP 上，所有传输内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，对称加密的密钥用服务器方的证书进用了非对称加密。所以HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li>
</ul>
</li>
</ul>
<h3 id="HTTP-1-0-和-HTTP-1-1-有什么区别？"><a href="#HTTP-1-0-和-HTTP-1-1-有什么区别？" class="headerlink" title="HTTP 1.0 和 HTTP 1.1 有什么区别？"></a>HTTP 1.0 和 HTTP 1.1 有什么区别？</h3><ul>
<li>连接方式：HTTP 1.0 为短连接，HTTP 1.1 支持长连接。</li>
<li>状态响应码：HTTP/1.1中新加入大量状态码。</li>
<li>缓存处理 : 在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, IfNone-Match 等更多可供选择的缓存头来控制缓存策略。</li>
<li>带宽优化及网络连接的使用：HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个 对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content）， 这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li>Host头处理 : HTTP/1.1在请求头中加入了 Host 字段。</li>
</ul>
<h3 id="HTTP-是不保存状态的协议-如何保存用户状态"><a href="#HTTP-是不保存状态的协议-如何保存用户状态" class="headerlink" title="HTTP 是不保存状态的协议, 如何保存用户状态?"></a>HTTP 是不保存状态的协议, 如何保存用户状态?</h3><ul>
<li>HTTP 是⼀种不保存状态，即无状态（stateless）协议。保存用户状态需要用到Session 机制。Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（⼀般情况下，服务器会在⼀定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。</li>
<li>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，大部分情况下，客户端通过在 Cookie 中附加⼀个 Session ID来跟踪。</li>
<li>Cookie 被禁用怎么办? 最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。</li>
</ul>
<h3 id="URI-和-URL-的区别是什么"><a href="#URI-和-URL-的区别是什么" class="headerlink" title="URI 和 URL 的区别是什么?"></a>URI 和 URL 的区别是什么?</h3><ul>
<li>URI(Uniform Resource Identifier) 是统⼀资源标志符，可以唯⼀标识⼀个资源。</li>
<li>URL(Uniform Resource Locator) 是统⼀资源定位符，可以提供该资源的路径。</li>
</ul>
<p>它是⼀种具体的 URI，即 URL 可以⽤来标识⼀个资源，⽽且还指明了如何 locate 这个资源。 URI 的作⽤像身份证号⼀样，URL 的作⽤更像家庭住址⼀样。URL 是⼀种具体的 URI，它不仅唯⼀ 标识资源，⽽且还提供了定位该资源的信息。</p>
<h3 id="GET和POST请求的区别？"><a href="#GET和POST请求的区别？" class="headerlink" title="GET和POST请求的区别？"></a>GET和POST请求的区别？</h3><p>GET和POST是HTTP协议的两种请求方式，主要区别是：</p>
<p><img src="https://pic4.zhimg.com/80/v2-ba440cf5ee0d73bf605fb3a6aeee49f7_720w.webp" alt="https://pic4.zhimg.com/80/v2-ba440cf5ee0d73bf605fb3a6aeee49f7_720w.webp" loading="lazy"></p>
<p>最大的区别是，请求带参数时，报文格式不同，GET方法的参数放在URL中，POST方法的参数放在请求体中。不带参数的请求，没有区别。</p>
<h3 id="TCP粘包问题"><a href="#TCP粘包问题" class="headerlink" title="TCP粘包问题"></a>TCP粘包问题</h3><ul>
<li>tcp粘包：就是指发送方发送的若干数据到接收方时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包的数据的尾</li>
<li>本质产生原因：tcp协议是面向字节流的，应用层协议没有定义消息的边界导致数据的接收方无法拼接数据</li>
<li>产生情况：</li>
<li>tcp连接复用造成的粘包问题<br>Nagle算法导致的粘包问题<br>数据包过大导致的粘包问题<br>流量控制、拥塞控制也可能导致粘包<br>接收方不及时接收缓冲区的包，造成多个包接收<br>解决方法：</li>
<li>发送方解决，关闭Nagle算法<br>应用层解决，尾部添加结束标记；发送数据定长</li>
</ul>
<h3 id="长连接、短连接"><a href="#长连接、短连接" class="headerlink" title="长连接、短连接"></a>长连接、短连接</h3><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。<br>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：Connection:keep-alive<br>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。<br>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p>
<h3 id="简述SYN攻击"><a href="#简述SYN攻击" class="headerlink" title="简述SYN攻击"></a>简述SYN攻击</h3><p>SYN攻击即利用TCP协议缺陷，通过发送大量的半连接请求，占用半连接队列，耗费CPU和内存资源。</p>
<p>优化方式：</p>
<ol>
<li>缩短SYN Timeout时间</li>
<li>记录IP，若连续受到某个IP的重复SYN报文，从这个IP地址来的包会被一概丢弃。</li>
</ol>
<p>MSL即报文最大生存时间。设置2MSL可以保证上一次连接的报文已经在网络中消失，不会出现与新TCP连接报文冲突的情况。</p>
<h3 id="转发和重定向的区别"><a href="#转发和重定向的区别" class="headerlink" title="转发和重定向的区别"></a>转发和重定向的区别</h3><p>转发是服务器行为。服务器直接向目标地址访问URL,将相应内容读取之后发给浏览器，用户浏览器地址栏URL不变，转发页面和转发到的页面可以共享request里面的数据。</p>
<p>重定向是利用服务器返回的状态码来实现的，如果服务器返回301或者302，浏览器收到新的消息后自动跳转到新的网址重新请求资源。用户的地址栏url会发生改变，而且不能共享数据。</p>
<h3 id="简述http2-0的改进"><a href="#简述http2-0的改进" class="headerlink" title="简述http2.0的改进"></a>简述http2.0的改进</h3><p>提出多路复用。多路复用前，文件时串行传输的，请求a文件，b文件只能等待，并且连接数过多。引入多路复用，a文件b文件可以同时传输。</p>
<p>引入了二进制数据帧。其中帧对数据进行顺序标识，有了序列id，服务器就可以进行并行传输数据。</p>
<h3 id="Get方法参数有大小限制吗"><a href="#Get方法参数有大小限制吗" class="headerlink" title="Get方法参数有大小限制吗"></a>Get方法参数有大小限制吗</h3><p>一般HTTP协议里并不限制参数大小限制。但一般由于get请求是直接附加到地址栏里面的，由于浏览器地址栏有长度限制，因此使GET请求在浏览器实现层面上看会有长度限制。</p>
<h3 id="为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态？"><a href="#为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态？" class="headerlink" title="为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？"></a>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</h3><p>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p>
<h3 id="如何对http1进行优化？"><a href="#如何对http1进行优化？" class="headerlink" title="如何对http1进行优化？"></a>如何对http1进行优化？</h3><ul>
<li>第⼀个思路是，通过缓存技术来避免发送 HTTP 请求。客户端收到第⼀个请求的响应后，可以将其缓存在本地磁盘，下次请求的时候，如果缓存没过期，就直接读取本地缓存的响应数据。如果缓存过期，客户端发送请求的时候带上响应数据的摘要，服务器⽐对后发现资源没有变化，就发出不带包体的 304 响应，告诉客户端缓存的响应仍然有效。</li>
<li>第⼆个思路是，减少 HTTP 请求的次数，有以下的⽅法：<ol>
<li>将原本由客户端处理的 定向请求，交给代理服务器处理，这样可以减少 定向请求的次数；</li>
<li>将多个⼩资源合并成⼀个⼤资源再传输，能够减少 HTTP 请求次数以及 头部的 复传输，再来减少 TCP 连<br>接数 ，进⽽省去 TCP 握⼿和慢启动的⽹络消耗；</li>
<li>按需访问资源，只访问当前⽤户看得到/⽤得到的资源，当客户往下滑动，再访问接下来的资源，以此达到延<br>迟请求，也就减少了同⼀时间的 HTTP 请求次数。</li>
</ol>
</li>
<li>第三思路是，通过压缩响应资源，降低传输资源的⼤⼩，从⽽提⾼传输效率，所以应当选择更优秀的压缩算法。</li>
</ul>
<h3 id="TLS-协议是如何解决-HTTP-的⻛险的呢？"><a href="#TLS-协议是如何解决-HTTP-的⻛险的呢？" class="headerlink" title="TLS 协议是如何解决 HTTP 的⻛险的呢？"></a>TLS 协议是如何解决 HTTP 的⻛险的呢？</h3><p>信息加密： HTTP 交互信息是被加密的，第三⽅就⽆法被窃取；<br>校验机制：校验信息传输过程中是否有被第三⽅篡改过，如果被篡改过，则会有警告提示；<br>身份证书：证明淘宝是真的淘宝⽹；</p>
<h3 id="http2优点："><a href="#http2优点：" class="headerlink" title="http2优点："></a>http2优点：</h3><ol>
<li>第⼀点，对于常⻅的 HTTP 头部通过静态表和 Huffman 编码的⽅式，将体积压缩了近⼀半，⽽且针对后续的请求头部，还可以建⽴动态表，将体积压缩近 90%，⼤⼤提⾼了编码效率，同时节约了带宽资源。不过，动态表并⾮可以⽆限增⼤， 因为动态表是会占⽤内存的，动态表越⼤，内存也越⼤，容易影响服务器总体的并发能⼒，因此服务器需要限制 HTTP/2 连接时⻓或者请求次数。</li>
<li>HTTP/2 实现了 Stream 并发，多个 Stream 只需复⽤ 1 个 TCP 连接，节约了 TCP 和 TLS 握⼿时间，以及减少了 TCP 慢启动阶段对流 的影响。不同的 Stream ID 才可以并发，即时乱序发送帧也没问题，但是同⼀个 Stream ⾥的帧必须严格有序。另外，可以根据资源的渲染顺序来设置 Stream 的优先级，从⽽提⾼⽤户体验。</li>
<li>服务器⽀持主动推送资源，⼤⼤提升了消息的传输性能，服务器推送资源时，会先发送 PUSH_PROMISE帧，告诉客户端接下来在哪个 Stream 发送资源，然后⽤偶数号 Stream 发送资源给客户端。</li>
</ol>
<h3 id="http2-缺点和http3-的改进"><a href="#http2-缺点和http3-的改进" class="headerlink" title="http2 缺点和http3 的改进"></a>http2 缺点和http3 的改进</h3><p>HTTP/2 虽然具有多个流并发传输的能⼒，但是传输层是 TCP 协议，于是存在以下缺陷：</p>
<ul>
<li>队头阻塞，HTTP/2 多个请求跑在⼀个 TCP 连接中，如果序列号较低的 TCP 段在⽹络传输中丢失了，即使序列号较⾼的 TCP 段已经被接收了，应⽤层也⽆法从内核中读取到这部分数据，从 HTTP 视⻆看，就是多个请求被阻塞了；</li>
<li>TCP 和 TLS 握⼿时延，TCL 三次握⼿和 TLS 四次握⼿，共有 3-RTT 的时延；</li>
<li>连接迁移需要重新连接，移动设备从 4G ⽹络环境切换到 WIFI 时，由于 TCP 是基于四元组来确认⼀条 TCP连接的，那么⽹络环境变化后，就会导致 IP 地址或端⼝变化，于是 TCP 只能断开连接，然后再 新建⽴连接，切换⽹络环境的成本⾼；</li>
</ul>
<p>HTTP/3 就将传输层从 TCP 替换成了 UDP，并在 UDP 协议上开发了 QUIC 协议，来保证数据的可靠传输。<br>QUIC 协议的特点：</p>
<ul>
<li>⽆队头阻塞，QUIC 连接上的多个 Stream 之间并没有依赖，都是独⽴的，也不会有底层协议限制，某个流发⽣丢包了，只会影响该流，其他流不受影响；</li>
<li>建⽴连接速度快，因为 QUIC 内部包含 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建⽴连接与 TLS 密钥协商，甚⾄在第⼆次连接的时候，应⽤数据包可以和 QUIC 握⼿信息（连接信息 + TLS 信息）⼀起发送，达到 0-RTT 的效果。</li>
<li>连接迁移，QUIC 协议没有⽤四元组的⽅式来“绑定”连接，⽽是通过「连接 ID 」来标记通信的两个端点，客户端和服务器可以各⾃选择⼀组 ID 来标记⾃⼰，因此即使移动设备的⽹络变化后，导致 IP 地址变化了，只要仍保有上下⽂信息（⽐如连接 ID、TLS 密钥等），就可以“⽆缝”地复⽤原连接，消除 连的成本；</li>
</ul>
<p>另外 HTTP/3 的 QPACK 通过两个特殊的单向流来同步双⽅的动态表，解决了 HTTP/2 的 HPACK 队头阻塞问题。</p>
<h3 id="什么是-SYN-攻击？如何避免-SYN-攻击？"><a href="#什么是-SYN-攻击？如何避免-SYN-攻击？" class="headerlink" title="什么是 SYN 攻击？如何避免 SYN 攻击？"></a>什么是 SYN 攻击？如何避免 SYN 攻击？</h3><ul>
<li>SYN 攻击：TCP 连接建⽴是需要三次握⼿，假设攻击者短时间伪造不同 IP 地址的 SYN 报⽂，服务端每接收到⼀个 SYN 报⽂，就进⼊ SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报⽂，⽆法得到未知 IP 主机的ACK 应答，久⽽久之就会占满服务端的 SYN 接收队列（未连接队列），使得服务器不能为正常⽤户服务。</li>
</ul>
<h3 id="为什么需要-TIME-WAIT-状态？"><a href="#为什么需要-TIME-WAIT-状态？" class="headerlink" title="为什么需要 TIME_WAIT 状态？"></a>为什么需要 TIME_WAIT 状态？</h3><p>主动发起关闭连接的⼀⽅，才会有 TIME-WAIT 状态。需要 TIME-WAIT 状态，主要是两个原因：</p>
<ul>
<li>防⽌具有相同「四元组」的「旧」数据包被收到；</li>
<li>保证「被动关闭连接」的⼀⽅能被正确的关闭，即保证最后的 ACK 能让被动关闭⽅接收，从⽽帮助其正常关闭；</li>
</ul>
<h3 id="TIME-WAIT-过多有什么危害？"><a href="#TIME-WAIT-过多有什么危害？" class="headerlink" title="TIME_WAIT 过多有什么危害？"></a>TIME_WAIT 过多有什么危害？</h3></div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="Donate" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><span class="icon iconify" data-icon="ri:hand-coin-line"></span></span><div id="reward-comment">I'm so cute. Please give me money.</div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>Aria</li><li class="post-copyright-link"><strong>Post link: </strong><a href="https://aria-geng.github.io/_myBlog/2023/04/30/InterviewExperience/" title="Interview Experience">https://aria-geng.github.io/_myBlog/2023/04/30/InterviewExperience/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> unless otherwise stated.</li></ul></article></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2023 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> Aria</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v5.4.2</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.9</span></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></body></html>