<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="Aria"><meta name="copyright" content="Aria"><meta name="generator" content="Hexo 5.4.2"><meta name="theme" content="hexo-theme-yun"><title>Computer Network|Browser|OS | Aria's NoteBook</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.4.1/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/svg+xml" href="/_myBlog/yun.svg"><link rel="mask-icon" href="/_myBlog/yun.svg" color="#0078E7"><link rel="preload" href="/_myBlog/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/_myBlog/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"aria-geng.github.io","root":"/_myBlog/","title":"云游君的小站","version":"1.10.9","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"fireworks":{"colors":null},"vendors":{"host":"https://fastly.jsdelivr.net/npm/","darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/_myBlog/css/hexo-theme-yun.css"><script src="/_myBlog/js/hexo-theme-yun.js" type="module"></script><meta name="description" content="Browser浏览器内核 渲染引擎  解释网页语法并渲染到网页上。负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。 常见的渲染引擎可以分这四种：Trident、Gecko、Blink、Webkit。   js 引擎：解析和执行 JavaScript 代码。chrome 的 javascript 解释器是 V8。   浏览器的标">
<meta property="og:type" content="article">
<meta property="og:title" content="Computer Network|Browser|OS">
<meta property="og:url" content="https://aria-geng.github.io/_myBlog/2023/04/30/CN|Browser|OS/index.html">
<meta property="og:site_name" content="Aria&#39;s NoteBook">
<meta property="og:description" content="Browser浏览器内核 渲染引擎  解释网页语法并渲染到网页上。负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。 常见的渲染引擎可以分这四种：Trident、Gecko、Blink、Webkit。   js 引擎：解析和执行 JavaScript 代码。chrome 的 javascript 解释器是 V8。   浏览器的标">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-0061badffc3a79c9e540bf0189b2647a_720w.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-ba440cf5ee0d73bf605fb3a6aeee49f7_720w.webp">
<meta property="article:published_time" content="2023-04-29T16:00:03.000Z">
<meta property="article:modified_time" content="2023-05-08T02:12:17.944Z">
<meta property="article:author" content="Aria">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic3.zhimg.com/80/v2-0061badffc3a79c9e540bf0189b2647a_720w.jpg"><script>(function() {
  if (CONFIG.mode !== 'auto') return
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/_myBlog/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/_myBlog/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/_myBlog/about/" title="Aria"><img width="96" loading="lazy" src="/_myBlog/yun.png" alt="Aria"></a><div class="site-author-name"><a href="/_myBlog/about/">Aria</a></div><span class="site-name">Aria's NoteBook</span><sub class="site-subtitle"></sub><div class="site-description"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/_myBlog/" title="Home"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/_myBlog/archives/" title="Archives"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">5</span></a></div><div class="site-state-item"><a href="/_myBlog/categories/" title="Categories"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">0</span></a></div><div class="site-state-item"><a href="/_myBlog/tags/" title="Tags"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">0</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:settings-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/_myBlog/links/" title="我的小伙伴们" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:genderless-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Browser"><span class="toc-number">1.</span> <span class="toc-text">Browser</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8"><span class="toc-number">1.1.</span> <span class="toc-text">浏览器内核</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%A0%87%E5%87%86%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%80%AA%E5%BC%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%94%B1%E6%9D%A5%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.</span> <span class="toc-text">浏览器的标准模式和怪异模式的由来和区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPA"><span class="toc-number">1.3.</span> <span class="toc-text">SPA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">1.3.2.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">1.3.3.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Computer-Network"><span class="toc-number">2.</span> <span class="toc-text">Computer Network</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#OSI-%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%EF%BC%8C%E6%AF%8F%E2%BC%80%E5%B1%82%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.1.</span> <span class="toc-text">OSI 七层模型，每⼀层的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP-%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B%E3%80%81%E6%AF%8F%E4%B8%80%E5%B1%82%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.2.</span> <span class="toc-text">TCP&#x2F;IP 四层模型、每一层的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">从输入URL到页面展示过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84"><span class="toc-number">2.4.</span> <span class="toc-text">浏览器的多进程架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DNS%E8%A7%A3%E6%9E%90"><span class="toc-number">2.5.</span> <span class="toc-text">DNS解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F"><span class="toc-number">2.5.1.</span> <span class="toc-text">DNS查询方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D%E7%BC%93%E5%AD%98%E6%96%B9%E5%BC%8F"><span class="toc-number">2.5.2.</span> <span class="toc-text">域名缓存方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">2.5.3.</span> <span class="toc-text">解析过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B"><span class="toc-number">2.6.</span> <span class="toc-text">浏览器渲染过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%B5%81%EF%BC%88%E9%87%8D%E6%8E%92%EF%BC%89%E5%92%8C%E9%87%8D%E7%BB%98"><span class="toc-number">2.7.</span> <span class="toc-text">回流（重排）和重绘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.7.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%9C%BA%E6%99%AF"><span class="toc-number">2.7.2.</span> <span class="toc-text">触发场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98"><span class="toc-number">2.7.3.</span> <span class="toc-text">避免回流重绘</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E4%B8%8EUDP"><span class="toc-number">2.8.</span> <span class="toc-text">TCP与UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">2.8.1.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.8.2.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8TCP%E3%80%81UDP%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.8.3.</span> <span class="toc-text">使用TCP、UDP的协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.9.</span> <span class="toc-text">TCP连接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E3%80%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">2.9.1.</span> <span class="toc-text">TCP建立连接、三次握手过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E6%88%96%E5%9B%9B%E6%AC%A1%EF%BC%9F"><span class="toc-number">2.9.2.</span> <span class="toc-text">TCP 为什么是三次握手而不是两次或四次？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BC%A0%E5%9B%9E%E4%BA%86ACK%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E4%BC%A0%E5%9B%9ESYN%EF%BC%9F"><span class="toc-number">2.10.</span> <span class="toc-text">第2次握手传回了ACK，为什么还要传回SYN？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5-TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">2.11.</span> <span class="toc-text">断开连接-TCP 四次挥手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F"><span class="toc-number">2.12.</span> <span class="toc-text">为什么要四次挥手？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%8A%8A%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E7%9A%84-ACK-%E5%92%8C-FIN-%E5%90%88%E5%B9%B6%E8%B5%B7%E6%9D%A5%EF%BC%8C%E5%8F%98%E6%88%90%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F"><span class="toc-number">2.13.</span> <span class="toc-text">为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%97%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84-ACK-%E6%B2%A1%E6%9C%89%E9%80%81%E8%BE%BE%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%8C%E4%BC%9A%E6%80%8E%E6%A0%B7%EF%BC%9F"><span class="toc-number">2.14.</span> <span class="toc-text">如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%852MSL%EF%BC%88%E6%8A%A5%E6%96%87%E6%AE%B5%E6%9C%80%E9%95%BF%E5%AF%BF%E5%91%BD%EF%BC%89%E6%97%B6%E9%97%B4%E5%90%8E%E6%89%8D%E8%BF%9B%E5%85%A5-CLOSED-%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">2.15.</span> <span class="toc-text">为什么第四次挥手客户端需要等待2MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%EF%BC%9F"><span class="toc-number">2.16.</span> <span class="toc-text">TCP 如何保证传输的可靠性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%EF%BC%9F%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">2.17.</span> <span class="toc-text">TCP 如何实现流量控制？（滑动窗口）为什么需要流量控制?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">2.18.</span> <span class="toc-text">TCP 的拥塞控制是怎么实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ARQ-%E5%8D%8F%E8%AE%AE%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">2.19.</span> <span class="toc-text">ARQ 协议了解吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">2.20.</span> <span class="toc-text">HTTP 状态码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GET-%E5%92%8C-POST-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.21.</span> <span class="toc-text">GET 和 POST 有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GET-%E5%92%8C-POST-%E6%96%B9%E6%B3%95%E9%83%BD%E6%98%AF%E5%AE%89%E5%85%A8%E5%92%8C%E5%B9%82%E7%AD%89%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">2.21.1.</span> <span class="toc-text">GET 和 POST 方法都是安全和幂等的吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E7%BC%93%E5%AD%98%E6%96%B9%E5%BC%8F%EF%BC%88%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%EF%BC%89"><span class="toc-number">2.22.</span> <span class="toc-text">HTTP 缓存方式（强制缓存和协商缓存）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-ETag-%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E6%9B%B4%E9%AB%98%EF%BC%9F"><span class="toc-number">2.22.0.1.</span> <span class="toc-text">为什么 ETag 的优先级更高？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E4%BD%BF%E7%94%A8-ETag-%E5%AD%97%E6%AE%B5%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">2.22.0.2.</span> <span class="toc-text">当使用 ETag 字段实现的协商缓存的过程：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E5%92%8C-HTTPS-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.23.</span> <span class="toc-text">HTTP 和 HTTPS 区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-number">2.24.</span> <span class="toc-text">对称加密</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-number">2.25.</span> <span class="toc-text">非对称加密</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB"><span class="toc-number">2.26.</span> <span class="toc-text">中间人攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6"><span class="toc-number">2.27.</span> <span class="toc-text">数字证书</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS-%E8%A7%A3%E5%86%B3%E4%BA%86-HTTP-%E7%9A%84%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">2.28.</span> <span class="toc-text">HTTPS 解决了 HTTP 的哪些问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86"><span class="toc-number">2.28.1.</span> <span class="toc-text">混合加密</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-1-0-%E5%92%8C-HTTP-1-1-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.28.2.</span> <span class="toc-text">HTTP 1.0 和 HTTP 1.1 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-1-1-%E7%9A%84%E4%BC%98%E7%82%B9%E3%80%81%E7%BC%BA%E7%82%B9%E5%92%8C%E6%80%A7%E8%83%BD"><span class="toc-number">2.28.3.</span> <span class="toc-text">HTTP&#x2F;1.1 的优点、缺点和性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E6%98%AF%E4%B8%8D%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81%E7%9A%84%E5%8D%8F%E8%AE%AE-%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E7%94%A8%E6%88%B7%E7%8A%B6%E6%80%81"><span class="toc-number">2.28.4.</span> <span class="toc-text">HTTP 是不保存状态的协议, 如何保存用户状态?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#URI-%E5%92%8C-URL-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.28.5.</span> <span class="toc-text">URI 和 URL 的区别是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GET%E5%92%8CPOST%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.28.6.</span> <span class="toc-text">GET和POST请求的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.28.7.</span> <span class="toc-text">TCP粘包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E8%BF%9E%E6%8E%A5%E3%80%81%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.28.8.</span> <span class="toc-text">长连接、短连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0SYN%E6%94%BB%E5%87%BB"><span class="toc-number">2.28.9.</span> <span class="toc-text">简述SYN攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.28.10.</span> <span class="toc-text">转发和重定向的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0http2-0%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">2.28.11.</span> <span class="toc-text">简述http2.0的改进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Get%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E6%9C%89%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6%E5%90%97"><span class="toc-number">2.28.12.</span> <span class="toc-text">Get方法参数有大小限制吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88TIME-WAIT%E7%8A%B6%E6%80%81%E9%9C%80%E8%A6%81%E7%BB%8F%E8%BF%872MSL-%E6%9C%80%E5%A4%A7%E6%8A%A5%E6%96%87%E6%AE%B5%E7%94%9F%E5%AD%98%E6%97%B6%E9%97%B4-%E6%89%8D%E8%83%BD%E8%BF%94%E5%9B%9E%E5%88%B0CLOSE%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">2.28.13.</span> <span class="toc-text">为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AF%B9http1%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">2.28.14.</span> <span class="toc-text">如何对http1进行优化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLS-%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-HTTP-%E7%9A%84%E2%BB%9B%E9%99%A9%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">2.28.15.</span> <span class="toc-text">TLS 协议是如何解决 HTTP 的⻛险的呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http2%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">2.28.16.</span> <span class="toc-text">http2优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http2-%E7%BC%BA%E7%82%B9%E5%92%8Chttp3-%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">2.28.17.</span> <span class="toc-text">http2 缺点和http3 的改进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-SYN-%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D-SYN-%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-number">2.28.18.</span> <span class="toc-text">什么是 SYN 攻击？如何避免 SYN 攻击？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-TIME-WAIT-%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">2.28.19.</span> <span class="toc-text">为什么需要 TIME_WAIT 状态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TIME-WAIT-%E8%BF%87%E5%A4%9A%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3%EF%BC%9F"><span class="toc-number">2.28.20.</span> <span class="toc-text">TIME_WAIT 过多有什么危害？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">2.29.</span> <span class="toc-text">地址栏输入url到页面呈现的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ajax%E3%80%81Fetch-%E4%B8%8E-axios"><span class="toc-number">2.30.</span> <span class="toc-text">ajax、Fetch 与 axios</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ajax"><span class="toc-number">2.30.1.</span> <span class="toc-text">ajax</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fetch"><span class="toc-number">2.30.2.</span> <span class="toc-text">Fetch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#axios"><span class="toc-number">2.30.3.</span> <span class="toc-text">axios</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fetch-%E4%B8%8E-Ajax-%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-number">2.30.4.</span> <span class="toc-text">Fetch 与 Ajax 的不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fetch-%E5%8F%91%E9%80%81-2-%E6%AC%A1%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.30.5.</span> <span class="toc-text">fetch 发送 2 次请求的原因</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cookie-%E4%B8%8E-Session"><span class="toc-number">2.31.</span> <span class="toc-text">Cookie 与 Session</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie-%E5%92%8C-Session-%E5%85%B1%E5%90%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">2.31.1.</span> <span class="toc-text">Cookie 和 Session 共同使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Token"><span class="toc-number">2.32.</span> <span class="toc-text">Token</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8-Token%E4%B8%8D%E7%94%A8-Cookie-Session-%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">2.33.</span> <span class="toc-text">用 Token不用 Cookie+Session 的优点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JWT"><span class="toc-number">2.33.1.</span> <span class="toc-text">JWT</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cookie-%E5%92%8C-token-%E9%83%BD%E5%AD%98%E6%94%BE%E5%9C%A8-header-%E4%B8%AD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BC%9A%E5%8A%AB%E6%8C%81-token%EF%BC%9F"><span class="toc-number">2.34.</span> <span class="toc-text">cookie 和 token 都存放在 header 中，为什么不会劫持 token？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E9%A1%B5%E9%9D%A2%E9%80%9A%E4%BF%A1"><span class="toc-number">2.35.</span> <span class="toc-text">跨页面通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F"><span class="toc-number">2.36.</span> <span class="toc-text">跨域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD"><span class="toc-number">2.36.1.</span> <span class="toc-text">查看网站性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96"><span class="toc-number">2.36.2.</span> <span class="toc-text">前端优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%8F%E5%B9%95%E5%8D%A1%E9%A1%BF"><span class="toc-number">2.36.3.</span> <span class="toc-text">屏幕卡顿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js-%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E9%98%BB%E5%A1%9E%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">2.36.4.</span> <span class="toc-text">js 加载过程阻塞，解决方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Operation-System"><span class="toc-number">3.</span> <span class="toc-text">Operation System</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">进程和线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E5%BC%80%E9%94%80"><span class="toc-number">3.2.</span> <span class="toc-text">进程切换开销</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E5%BC%80%E9%94%80"><span class="toc-number">3.3.</span> <span class="toc-text">线程切换开销</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">3.4.</span> <span class="toc-text">进程通信</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="https://aria-geng.github.io/_myBlog/_myBlog/2023/04/30/CN%7CBrowser%7COS/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Aria"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Aria's NoteBook"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Computer Network|Browser|OS</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="Created: 2023-04-30 00:00:03" itemprop="dateCreated datePublished" datetime="2023-04-30T00:00:03+08:00">2023-04-30</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-2-line"></span></span> <time title="Modified: 2023-05-08 10:12:17" itemprop="dateModified" datetime="2023-05-08T10:12:17+08:00">2023-05-08</time></div><div class="post-classify"></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h1 id="Browser"><a href="#Browser" class="headerlink" title="Browser"></a>Browser</h1><h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><ul>
<li><p>渲染引擎</p>
<ul>
<li>解释网页语法并渲染到网页上。负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</li>
<li>常见的渲染引擎可以分这四种：Trident、Gecko、Blink、Webkit。</li>
</ul>
</li>
<li><p>js 引擎：解析和执行 JavaScript 代码。chrome 的 javascript 解释器是 V8。</p>
</li>
</ul>
<h2 id="浏览器的标准模式和怪异模式的由来和区别"><a href="#浏览器的标准模式和怪异模式的由来和区别" class="headerlink" title="浏览器的标准模式和怪异模式的由来和区别"></a>浏览器的标准模式和怪异模式的由来和区别</h2><ul>
<li>出现背景：HTML和CSS标准之前，浏览器对html和css的解析有各自不同的方式，很多旧版本的网页都是按照非标准的模式实现的页面，在HTMl和CSS标准定义完成后，浏览器开始按照w3c规定标准来解析页面，还需要保证之前的页面能够正常显示，所以浏览器都会有两种渲染模式：标准模式和怪异模式，在标准模式下，浏览器按照w3c提供的标准解析和渲染页面，在怪异模式下，浏览按照非标准的方式对文档进行解析渲染，</li>
<li>浏览会根据html doctype确定使用哪种模式执行页面的渲染</li>
<li>区别 <ul>
<li>大小计算法方式<ul>
<li>盒子模型<ul>
<li>标准模式下IE盒模型（content（宽高） + 填充padding + 边框border + 边距margin）</li>
<li>怪异模式下（content + maring）而content区域包括了（content，padding，border）</li>
<li>在css3中可以通过 box-sizing来控制盒模型content-box, padding-box, border-box</li>
</ul>
</li>
<li>行内元素的高度：标准模式下不生效，怪异模式下会生效</li>
<li>margin： 在标准模式下margin: 0 auto; 会水平居中，怪异模式下不会</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>SPA/Single Page Application/单页面应用指的是只有一个页面的应用，只需要加载一次HTML、CSS、JavaScript等相关资源，一旦页面加载完成，不会因为用户的操作进行页面的重新加载或跳转，而是利用<strong>路由机制</strong>来刷新<strong>局部资源</strong>。</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>切换速度快，用户体验好，内容的改变不需要重新加载整个页面，避免了不必要的重复渲染和跳转。</li>
<li>SPA对服务器压力小（REASON：基于上面一点）。</li>
<li>良好的前后端分离，分工明确。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>初次加载耗时多。</li>
<li>SPA在一个页面中显示所有内容，所以不能使用浏览器的前进后退功能，页面切换需要自己建立堆栈管理。</li>
<li>SEO难度较大：所有的内容都在一个页面中动态替换显示，所以SPA在SEO上有着天然的弱势。</li>
</ul>
<h1 id="Computer-Network"><a href="#Computer-Network" class="headerlink" title="Computer Network"></a>Computer Network</h1><h2 id="OSI-七层模型，每⼀层的作用"><a href="#OSI-七层模型，每⼀层的作用" class="headerlink" title="OSI 七层模型，每⼀层的作用"></a>OSI 七层模型，每⼀层的作用</h2><ul>
<li><p>OSI 七层模型 是国际标准化组织提出⼀个网络分层模型</p>
<p><img src="https://pic3.zhimg.com/80/v2-0061badffc3a79c9e540bf0189b2647a_720w.jpg" loading="lazy"></p>
</li>
<li><p>每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到那里。</p>
</li>
</ul>
<h2 id="TCP-IP-四层模型、每一层的作用"><a href="#TCP-IP-四层模型、每一层的作用" class="headerlink" title="TCP/IP 四层模型、每一层的作用"></a>TCP/IP 四层模型、每一层的作用</h2><ul>
<li>TCP/IP 四层模型 是目前被广泛采用的一种模型，是 OSI 七层模型的精简版本，包括应用层，传输层，网络层，网络接口层。<ul>
<li>应用层：提供两个终端设备应用程序之间信息交换的服务<ul>
<li>定义了<ul>
<li>信息交换的格式；</li>
<li>网络通信规则，如支持 Web 应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。</li>
</ul>
</li>
</ul>
</li>
<li>传输层：负责向两台终端设备进程之间的通信提供通用的数据传输服务。<ul>
<li>主要使用以下两种协议：<ul>
<li>TCP提供面向连接的，可靠的数据传输服务。</li>
<li>UDP提供无连接的，尽最大努力的数据传输服务 （不保证数据传输的可靠性）。</li>
</ul>
</li>
</ul>
</li>
<li>网络层：为分组交换网上的不同主机提供通信服务。<ul>
<li>发送数据把传输层产生的 报文段 或 用户数据报 封装 成 <strong>分组</strong> 和 包 进行传送。</li>
<li>常见的协议有IP、ARP、NAT协议。</li>
</ul>
</li>
<li>网络接口层：数据链路层和物理层的合体。<ul>
<li>数据链路层：将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。<ul>
<li>每⼀帧包括数据和必要的控制信息：如同步信息，地址信息，差错控制 等。</li>
</ul>
</li>
<li>物理层：实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="从输入URL到页面展示过程"><a href="#从输入URL到页面展示过程" class="headerlink" title="从输入URL到页面展示过程"></a>从输入URL到页面展示过程</h2><ul>
<li>用户输入URL</li>
<li>浏览器进程检查URL，组装协议，构成完整的URL，然后通过进程间通信（IPC）把URL请求发送给网络进程</li>
<li>网络进程接收到URL请求后检查本地缓存是否缓存了请求资源，如果有则将该资源返回给浏览器进程</li>
<li>如果没有，网络进程向web服务器发起http请求（网络请求）<ul>
<li>进行DNS解析，获取服务器ip地址，端口（端口是通过dns解析获取的吗？这里有个疑问）</li>
<li>利用ip地址和服务器建立tcp连接</li>
<li>构建和发送请求头信息</li>
</ul>
</li>
<li>服务器响应后，网络进程接收响应头和响应信息，并解析响应内容<ul>
<li>检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步 （301/302跳转也会读取本地缓存吗？这里有个疑问），如果是200，则继续处理请求。</li>
<li>200响应处理：检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染，如果是html则通知浏览器进程准备渲染进程准备进行渲染。</li>
</ul>
</li>
<li>浏览器进程检查当前url和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程</li>
<li>渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”，接收完数据后，向浏览器发送“确认提交”</li>
<li>浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面</li>
</ul>
<h2 id="浏览器的多进程架构"><a href="#浏览器的多进程架构" class="headerlink" title="浏览器的多进程架构"></a>浏览器的多进程架构</h2><p>从浏览器输入 <code>URL</code> 到页面渲染的整个过程都是由 浏览器架构中的各个进程之间的配合完成。</p>
<ol>
<li>浏览器主进程: 管理子进程、提供服务功能</li>
<li>渲染进程：将HTML、CSS、JS渲染成界面，js引擎v8和排版引擎Blink就在上面，他会为每一个tab页面创建一个渲染进程</li>
<li>GPU进程：本来是负责处理3Dcss的，后来慢慢的UI界面也交给GPU来绘制</li>
<li>网络进程：就是负责网络请求，网络资源加载的进程</li>
<li>插件进程：负责插件的运行的，因为插件很容易崩溃，把它放到独立的进程里不要让它影响别人</li>
</ol>
<h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><h3 id="DNS查询方式"><a href="#DNS查询方式" class="headerlink" title="DNS查询方式"></a>DNS查询方式</h3><ul>
<li><p>递归查询：如果 A 请求 B，那么 B 作为请求的接收者一定要给 A 想要的答案</p>
</li>
<li><p>迭代查询：如果接收者 B 没有请求者 A 所需要的准确内容，接收者 B 将告诉请求者 A，如何去获得这个内容，但是自己并不去发出请求</p>
</li>
</ul>
<h3 id="域名缓存方式"><a href="#域名缓存方式" class="headerlink" title="域名缓存方式"></a>域名缓存方式</h3><ul>
<li>浏览器缓存：浏览器在获取网站域名的实际 IP 地址后会进行缓存，减少网络请求的损耗</li>
<li>操作系统缓存：用户自己配置的 <code>hosts</code> 文件</li>
</ul>
<h3 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h3><ul>
<li>首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表</li>
<li>若没有命中，则继续搜索操作系统的 DNS 缓存</li>
<li>若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果</li>
<li>若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询<ul>
<li>首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器</li>
<li>本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址</li>
<li>本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址</li>
</ul>
</li>
<li>本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来</li>
<li>操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存</li>
</ul>
<h2 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h2><ul>
<li>浏览器无法直接读取html，先构建Dom树。</li>
<li>把读取到的css，变成浏览器可以理解的cssom树</li>
<li>标准化转换样式表中的属性值。比如2em被解析成32px，red被解析成了rgb(255,0,0)，bold被解析成了 700……</li>
<li>利用css继承、css优先级、css层叠规则等计算计算DOM树中每个节点的具体样式。</li>
<li>浏览器从DOM树的根节点开始遍历每个可见节点，并把这些节点添加到渲染树中。不可见的节点不会添加到渲染树，比如css设置了display为none 属性的节点。</li>
<li>根据生成的渲染树，进行布局（也可以叫做回流），得到各个节点在页面中的确切位置和大小。（自动重排）。布局阶段的输出是一个盒子模型，精确捕获每个元素在屏幕内的位置与大小，所有相对的测量值转换为屏幕内的绝对像素值（重绘）。</li>
<li>生成分层树，页面一层一层叠加在一起形成。比如一些复杂的css动画，z-index等，渲染引擎会为他们生成专用的图层，并生成对应的图层树。</li>
<li>构建完图层之后，渲染引擎对图层树中的每个元素进行绘制。合成线程把分层树的图层变成图块。</li>
<li>GPU的栅格化把视窗附近的图块变成位图，然后保存在GPU的进程中。（因为一个页面可能很大，而用户只能看到视口中页面的一部分，如果全部绘制开销会很大，所以合成线程会按照视口附近的图块来优先生成位图）</li>
<li>栅格化完成之后，浏览器进去GPU进程里取出页面内容显示在屏幕上，这就完成了渲染阶段。</li>
</ul>
<h2 id="回流（重排）和重绘"><a href="#回流（重排）和重绘" class="headerlink" title="回流（重排）和重绘"></a>回流（重排）和重绘</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><ul>
<li><p>浏览器渲染页面过程中</p>
<ul>
<li><p>首先解析HTML，生成DOM树，解析CSS，生成CSSOM树</p>
</li>
<li><p>将DOM树和CSSOM树结合，生成渲染树(Render Tree)</p>
</li>
<li><p>Layout(回流)是根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</p>
</li>
<li><p>Painting(重绘)是根据渲染树以及回流得到的几何信息，得到节点的绝对像素和外观</p>
</li>
</ul>
</li>
<li><p>回流：也叫重排，当 DOM 的变化影响了元素的几何信息（位置、尺寸大小等），浏览器重新计算元素的几何属性，放在界面的正确位置。</p>
</li>
<li><p>重绘：是当一个元素的外观发生变化，但没有改变布局，重新把元素外观绘制出来的过程。</p>
</li>
</ul>
<h3 id="触发场景"><a href="#触发场景" class="headerlink" title="触发场景"></a>触发场景</h3><ul>
<li><p>回流：当页面布局和几何信息发生变化的时候就需要回流</p>
<ul>
<li>页面初始渲染，这是开销最大的一次重排</li>
<li>添加/删除可见的DOM元素</li>
<li>改变元素位置</li>
<li>改变元素尺寸，比如边距、填充、边框、宽度和高度等</li>
<li>改变元素内容，比如文字数量，图片大小等</li>
<li>改变元素字体大小</li>
<li>改变浏览器窗口尺寸，比如resize事件发生时（因为回流是根据视口的大小来计算元素的位置和大小的）</li>
<li>激活CSS伪类（例如：:hover）</li>
<li>设置 style 属性的值，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow</li>
<li>查询某些属性或调用某些计算方法（共性是需要通过即时计算得到）<ul>
<li>offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight等</li>
<li>调用getComputedStyl方法，或者IE里的 currentStyle 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”。</li>
</ul>
</li>
</ul>
</li>
<li><p>重绘</p>
<ul>
<li><p>回流发生时一定会触发重绘</p>
</li>
<li><p>可见性(visibility)和透明度(opacity)的改变</p>
</li>
<li><p>颜色的改变</p>
</li>
<li><p>背景的改变</p>
</li>
<li><p>阴影、轮廓的改变</p>
</li>
<li><p>文本方向(text-decoration)的改变等</p>
</li>
</ul>
</li>
</ul>
<h3 id="避免回流重绘"><a href="#避免回流重绘" class="headerlink" title="避免回流重绘"></a>避免回流重绘</h3><ul>
<li>浏览器对于回流和重绘的优化<ul>
<li>浏览器维护一个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定数量或者到了一定的时间间隔，浏览器就会 flush 队列，进行一个批处理。让多次的回流、重绘变成一次回流重绘。</li>
<li>当获取布局信息的操作的时候，例如 offsetTop 等，为了保证获取结果的准确性，就会打破浏览器的这种优化策略，强制浏览器提前 flush 队列。</li>
</ul>
</li>
<li>css 中避免回流和重绘<ul>
<li>减少回流范围，尽量将需要回流的内容固定在局部范围。</li>
<li>不要使用 table 布局，可能很小的一个改动会造成整个 table 的重新布局。不得已使用 table 的场景，可以设置 table-layout: auto; 或者 table-layout: fixed; 这样可以让 table 一行一行的渲染，同时可可以限制回流的影响范围。</li>
<li>集中修改样式。这样可以尽可能利用浏览器的优化机制，一次回流重绘就完成渲染。</li>
<li>避免设置多项内联样式。</li>
<li>如果想设定元素的样式，可以通过改变元素的 class 类名（尽可能在 DOM 树的最里层）。</li>
<li>将 DOM 离线。通过设置元素属性 display: none; 将其从页面上去掉，然后再进行后续操作，这些后续操作将不会出发回流、重绘，最后通过 display 属性显示。另外，visibility: hidden 的元素只对重绘有影响，不影响回流。</li>
<li>使用 position: absolute / fixed; 脱离文档流。例如那些复杂的动画，对其设置 position: absolute / fixed; 尽可能地使元素脱离文档流，从而减少对其他元素的影响。</li>
<li>利用 transform translate 代替 left top 的变换。</li>
<li>使用 css3 硬件加速，可以让 transform、opacity、filters 这些动画不会引起回流重绘。</li>
<li>避免使用 css 的 JavaScript 表达式。</li>
<li>将频繁回流或重绘的节点设置为图层。将节点设置为 video 或 iframe；为节点添加 will-change 属性。</li>
</ul>
</li>
<li>js 中避免回流和重绘<ul>
<li>减少直接操作 DOM 元素。不要一条一条地修改 DOM 的样式，改用 className 来控制。</li>
<li>分离读写操作。当需要 js 操作元素样式时，即将获取样式属性的操作集中执行，并缓存值，在需要设置样式属性时也集中处理，避免获取和设置的操作互相夹杂。因为获取、设置的操作都会引起回流。</li>
<li>动态插入多个节点时，可以使用文档碎片（DocumentFragment），创建后一次插入，避免多次的渲染性能。DocumnetFragment 是一个保存多个元素的容器对象（保存在内存），当更新其中的一个或者多个元素时，页面不会更新。</li>
<li>不要把 DOM 节点的 offsetLeft 等属性值放在一个循环里当成循环里的变量。</li>
<li>使用 resize 事件时，做防抖和节流处理。</li>
</ul>
</li>
</ul>
<h2 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li><p>UDP无连接；TCP提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后释放连接。</p>
</li>
<li><p>TCP提供可靠的传输服务，传递数据前有三次握手建立连接，传递时，有确认、窗⼝、重传、拥塞控制机制，传输的数据无差错、不丢失、不重复、并且按序到达；UDP是尽可能传递数据，不保证数据不丢失和顺序到达。</p>
</li>
<li><p>TCP传输有状态，会去记录自己发送消息的状态：比如消息是否发送了、是否被接收了，需要维持复杂的连接状态表；UDP无状态服务，不管发出去之后的事情。</p>
</li>
<li><p>传输效率：TCP传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</p>
</li>
<li><p>传输形式：TCP 面向字节流，将应用层报文看成一串无结构的字节流，分解为多个TCP报文段传输后，在目的站重新装配。UDP协议面向报文，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后交给上层应用。</p>
</li>
<li><p>首部开销：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要⼤。</p>
</li>
<li><p>TCP 只⽀持点对点通信，UDP ⽀持⼀对⼀、⼀对多、多对⼀、多对 多。</p>
</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>UDP：即时通信，如语音、 视频 、直播。对传输数据的准确性要求不是特别高，比如看视频即使少个一两帧，实际感觉区别也不大。</li>
<li>TCP：对传输准确性要求特别高的场景，比如文件传输、发送和接收邮件、远程登录等。</li>
</ul>
<h3 id="使用TCP、UDP的协议"><a href="#使用TCP、UDP的协议" class="headerlink" title="使用TCP、UDP的协议"></a>使用TCP、UDP的协议</h3><ul>
<li>运行于 TCP 协议之上的协议<ul>
<li>HTTP 协议 ：超⽂本传输协议，主要为 Web 浏览器之间的通信设计。浏览器网页通过 HTTP 请求加载。</li>
<li>HTTPS 协议 ：更安全的超文本传输协议</li>
<li>FTP 协议：文件传输协议提供文件传输服务,屏蔽操作系统和文件存储方式。</li>
<li>SMTP 协议：简单邮件传输协议，发送电子邮件。</li>
<li>SSH 协议：专为远程登录会话和其他网络服务提供安全性的协议，有效防止远程管理过程中的信息泄露。</li>
</ul>
</li>
<li>运行于 UDP 协议之上的协议 ：<ul>
<li>DNS：域名系统，同时支持 UDP 和 TCP 协议，将人类可读的域名 (<a target="_blank" rel="noopener" href="http://如www.baidu.com/">如www.baidu.com</a>) 转换为机器可读的 IP 地址 (如220.181.38.148)。</li>
</ul>
</li>
</ul>
<h2 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h2><h3 id="TCP建立连接、三次握手过程"><a href="#TCP建立连接、三次握手过程" class="headerlink" title="TCP建立连接、三次握手过程"></a>TCP建立连接、三次握手过程</h3><p>（目的：建立可靠的通信信道，双方确认发送与接收正常）</p>
<ol>
<li><p>客户端——-&gt;SYN标志的数据包——-&gt;服务端(然后SYN_SEND状态，等待服务器确认)；</p>
</li>
<li><p>服务端——-&gt;SYN+ACK标志的数据包——-客户端（SYN_RECV）；</p>
</li>
<li><p>客户端——-&gt;ACK(ACK=y+1)标志的数据包——-&gt;服务端，客户端和服务器都进入ESTABLISHED 状态。</p>
<p>（如果客户端发给服务器的同步信号丢了，客户端不会重传，但是服务器没有收到客户端的ACK会超时重传自己的SYN信号，直到收到客户端的ACK为止）</p>
</li>
</ol>
<h3 id="TCP-为什么是三次握手而不是两次或四次？"><a href="#TCP-为什么是三次握手而不是两次或四次？" class="headerlink" title="TCP 为什么是三次握手而不是两次或四次？"></a>TCP 为什么是三次握手而不是两次或四次？</h3><p>TCP连接握手，其实是传输数据原点的序列号</p>
<ul>
<li><p>四次握手过程 1. 2. 服务器确认收到客户端的同步信号，并记录客户端的ISN到本地，命名为服务器的ACK 3. 服务器发送同步信号SYN和服务器的初始序列号 4.</p>
<p>2和3可以合并，只需要三次握手，提高连接的速度与效率。</p>
</li>
<li><p>两次握手：去掉最后一次握手，客户端和服务器就客户端的初始序列号达成一致，但是服务器不知道客户端是否收到自己的同步信号</p>
</li>
</ul>
<h2 id="第2次握手传回了ACK，为什么还要传回SYN？"><a href="#第2次握手传回了ACK，为什么还要传回SYN？" class="headerlink" title="第2次握手传回了ACK，为什么还要传回SYN？"></a>第2次握手传回了ACK，为什么还要传回SYN？</h2><ul>
<li>服务端传回发送端所发送的 ACK：告诉客户端自己接收到的信息就是客户端所发送的信号，从客户端到服务端的通信是正常的。</li>
<li>回传 SYN 是为了建立并确认从服务端到客户端的通信。</li>
</ul>
<h2 id="断开连接-TCP-四次挥手"><a href="#断开连接-TCP-四次挥手" class="headerlink" title="断开连接-TCP 四次挥手"></a>断开连接-TCP 四次挥手</h2><ol>
<li>客户端——&gt;FIN（SEQ=X）标志的数据包——-&gt;服务端，关闭客户端到服务器的数据传送,客户端进入 <strong>FIN-WAIT-1</strong> 状态。</li>
<li>服务器收到这个 FIN（SEQ=X） 标志的数据包，发送一个 ACK （SEQ=X+1）标志的数据包到客户端 。然后服务器进入<strong>CLOSE-WAIT</strong>状态，客户端进入<strong>FIN-WAIT-2</strong>状态。</li>
<li>服务端关闭与客户端的连接并发送一个 FIN (SEQ=y) 标志的数据包到客户端请求关闭连接，然后，服务端进入<strong>LAST-ACK</strong>状态。</li>
<li>客户端发送 ACK (SEQ=y+1)标志的数据包到服务端并且进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (SEQ=y+1)标志的数据包后进入 <strong>CLOSE</strong> 状态。此时，如果客户端等待 <strong>2MSL</strong> 时间（2min）后依然没有收到回复，就证明服务端已正常关闭，随后客户端也关闭连接。</li>
</ol>
<p><strong>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</strong></p>
<h2 id="为什么要四次挥手？"><a href="#为什么要四次挥手？" class="headerlink" title="为什么要四次挥手？"></a>为什么要四次挥手？</h2><p>TCP是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p>
<h2 id="为什么不能把服务器发送的-ACK-和-FIN-合并起来，变成三次挥手？"><a href="#为什么不能把服务器发送的-ACK-和-FIN-合并起来，变成三次挥手？" class="headerlink" title="为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？"></a>为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</h2><p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。</p>
<h2 id="如果第二次挥手时服务器的-ACK-没有送达客户端，会怎样？"><a href="#如果第二次挥手时服务器的-ACK-没有送达客户端，会怎样？" class="headerlink" title="如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？"></a>如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</h2><p>客户端没有收到 ACK 确认，会重新发送 FIN 请求。</p>
<h2 id="为什么第四次挥手客户端需要等待2MSL（报文段最长寿命）时间后才进入-CLOSED-状态？"><a href="#为什么第四次挥手客户端需要等待2MSL（报文段最长寿命）时间后才进入-CLOSED-状态？" class="headerlink" title="为什么第四次挥手客户端需要等待2MSL（报文段最长寿命）时间后才进入 CLOSED 状态？"></a>为什么第四次挥手客户端需要等待2MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</h2><ul>
<li>第四次挥手时，客户端发送给服务器的 ACK 有可能丢失；</li>
<li>如果服务端没有收到 ACK 会重发 FIN，如果客户端在 2MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 服务器 没有收到 ACK 而不断重发 FIN。</li>
</ul>
<blockquote>
<p>MSL(Maximum Segment Lifetime) : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，客户端 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。</p>
</blockquote>
<h2 id="TCP-如何保证传输的可靠性？"><a href="#TCP-如何保证传输的可靠性？" class="headerlink" title="TCP 如何保证传输的可靠性？"></a>TCP 如何保证传输的可靠性？</h2><ol>
<li><p><strong>基于数据快传输</strong> ：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层。</p>
</li>
<li><p><strong>对失序数据包重新排序以及去重</strong>：TCP 给每个包一个序列号，将接收到的数据根据序列号排序，并去掉重复序列号的数据就可以去重。</p>
</li>
<li><p><strong>校验和</strong> : 保持 首部 和 数据的检验和，检测数据在传输过程中的任何变化。如果收到段的 检验和 有差错就丢弃并且不确认收到。</p>
</li>
<li><p><strong>超时重传</strong> : 发送方发送数据后启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回相应确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，对应的数据包就被假设为已丢失并重传。</p>
</li>
<li><p><strong>流量控制</strong> : TCP 连接的每一方都有固定大小的缓冲空间，接收端只允许发送端发送接收端缓冲区能接纳的数据。当来不及处理时提示发送方降低发送的速率，防止包丢失。</p>
<p>TCP 使用的流量控制协议是可变大小的滑动窗口协议。</p>
</li>
<li><p><strong>拥塞控制</strong> : 当网络拥塞时，减少数据的发送。</p>
</li>
</ol>
<h2 id="TCP-如何实现流量控制？（滑动窗口）为什么需要流量控制"><a href="#TCP-如何实现流量控制？（滑动窗口）为什么需要流量控制" class="headerlink" title="TCP 如何实现流量控制？（滑动窗口）为什么需要流量控制?"></a>TCP 如何实现流量控制？（滑动窗口）为什么需要流量控制?</h2><p>通信时发送方与接收方的速率不一定相等，发送方的发送速率太快，接收方会处理不过来，把处理不过来的数据存在 <strong>接收缓冲区(Receiving Buffers)</strong> 里。如果缓存区满了发送方还在发数据的话，接收方只能把收到的数据包丢掉。丢包也浪费网络资源</p>
<h2 id="TCP-的拥塞控制是怎么实现的？"><a href="#TCP-的拥塞控制是怎么实现的？" class="headerlink" title="TCP 的拥塞控制是怎么实现的？"></a>TCP 的拥塞控制是怎么实现的？</h2><ul>
<li>拥塞：对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。</li>
<li>TCP 发送方维持一个拥塞窗口(cwnd)的状态变量，窗口大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。<ul>
<li><strong>慢开始：</strong> 主机开始发送数据时由小到大逐渐增大发送窗口。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</li>
<li><strong>拥塞避免：</strong> 每经过一个往返时间 RTT 就把发送放的 cwnd 加 1.</li>
<li>快重传与快恢复（FRR）：如果接收机接收到一个不按顺序的数据段，会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。<ul>
<li>当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。</li>
<li>当有多个数据信息包在某一段很短的时间内丢失时，不能很有效地工作。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="ARQ-协议了解吗？"><a href="#ARQ-协议了解吗？" class="headerlink" title="ARQ 协议了解吗？"></a>ARQ 协议了解吗？</h2><ul>
<li><p>自动重传请求</p>
<p>：数据链路层和传输层的错误纠正协议，使用确认和超时在不可靠服务的基础上实现可靠的信息传输。</p>
<ul>
<li>如果发送方在发送后一段时间之内没有收到确认信息（Acknoledgements，就是我们常说的 ACK），会重新发送，直到收到确认或者重试超过一定的次数。</li>
<li>包括停止等待 ARQ 协议和连续 ARQ 协议。<ul>
<li>停止等待 ARQ 协议：每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了超时时间还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</li>
<li>连续 ARQ 协议：发送方维持一个发送窗口，位于发送窗口内的分组可以连续发送出去，不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。<ul>
<li><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失也不必重传。</li>
<li><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h2><ul>
<li>1xx：消息类，服务器收到请求，需要请求者继续执行操作。</li>
<li>2xx：成功类，请求被成功接受并处理。<ul>
<li>200 OK，表示从客户端发来的请求在服务器端被正确处理</li>
<li>204 No content，表示请求成功，但响应报文不含实体的主体部分</li>
<li>206 Partial Content，进行范围请求</li>
</ul>
</li>
<li>3xx：重定向类，需要进一步操作完成请求。<ul>
<li>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL</li>
<li>302 found，临时性重定向，表示资源临时被分配了新的 URL</li>
<li>303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源</li>
<li>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况</li>
<li>307 temporary redirect，临时重定向，和302含义相同</li>
</ul>
</li>
<li>4xx：客户端错误类，客户端请求出错，服务器无法处理请求。<ul>
<li>400 bad request，请求报文存在语法错误</li>
<li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</li>
<li>403 forbidden，表示对请求资源的访问被服务器拒绝</li>
<li>404 not found，表示在服务器上没有找到请求的资源</li>
</ul>
</li>
<li>5xx/6xx：服务器错误类，服务器处理请求出错。</li>
</ul>
<h2 id="GET-和-POST-有什么区别？"><a href="#GET-和-POST-有什么区别？" class="headerlink" title="GET 和 POST 有什么区别？"></a>GET 和 POST 有什么区别？</h2><ul>
<li><strong>GET 的语义是从服务器获取指定的资源</strong>，如静态的文本、页面、图片视频等。GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符 ，而且浏览器会对 URL 的长度有限制（HTTP协议本身对 URL长度并没有做任何规定）。比如，打开网页浏览器就会发送 GET 请求给服务器，服务器就会返回网页的资源。</li>
<li><strong>POST 的语义是根据请求负荷（报文body）对指定的资源做出处理</strong>，具体的处理方式视资源类型而不同。POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。比如，在网页留言后点击「提交」，浏览器就会执行一次 POST 请求，把你的留言文字放进了报文 body 里，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器。</li>
</ul>
<h3 id="GET-和-POST-方法都是安全和幂等的吗？"><a href="#GET-和-POST-方法都是安全和幂等的吗？" class="headerlink" title="GET 和 POST 方法都是安全和幂等的吗？"></a>GET 和 POST 方法都是安全和幂等的吗？</h3><ul>
<li>「安全」：请求方法不会「破坏」服务器上的资源。</li>
<li>「幂等」：多次执行相同的操作，结果都是「相同」的。</li>
<li><strong>GET 方法就是安全且幂等的</strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，<strong>可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签</strong>。</li>
<li><strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。所以，<strong>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</strong>。</li>
</ul>
<h2 id="HTTP-缓存方式（强制缓存和协商缓存）"><a href="#HTTP-缓存方式（强制缓存和协商缓存）" class="headerlink" title="HTTP 缓存方式（强制缓存和协商缓存）"></a>HTTP 缓存方式（强制缓存和协商缓存）</h2><ul>
<li><p>强制缓存：只要浏览器判断缓存没有过期就使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。</p>
<ul>
<li><p>利用两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：</p>
<ul>
<li><code>Cache-Control</code>， 是一个相对时间；</li>
<li><code>Expires</code>，是一个绝对时间；</li>
</ul>
<p>如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，<strong>Cache-Control 的优先级高于 Expires</strong> 。</p>
<p>Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。</p>
</li>
<li><p>实现流程</p>
<ul>
<li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</li>
<li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li>
<li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</li>
</ul>
</li>
</ul>
</li>
<li><p>协商缓存：与服务端协商之后，通过协商结果来判断是否使用本地缓存。</p>
<ul>
<li><p>基于两种头部来实现。</p>
<ul>
<li><p>请求头部中的 <code>If-Modified-Since</code> 字段与响应头部中的 <code>Last-Modified</code> 字段实现</p>
<ul>
<li>响应头部中的 <code>Last-Modified</code>：标示这个响应资源的最后修改时间；</li>
<li>请求头部中的 <code>If-Modified-Since</code>：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。</li>
</ul>
</li>
<li><p>请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段</p>
<ul>
<li><p>响应头部中 <code>Etag</code>：唯一标识响应资源；</p>
</li>
<li><p>请求头部中的 <code>If-None-Match</code>：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</p>
</li>
</ul>
</li>
</ul>
<p>第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。</p>
<p>如果在第一次请求资源的时候，服务端返回的 HTTP 响应头部同时有 Etag 和 Last-Modified 字段，那么客户端再下一次请求的时候，如果带上了 ETag 和 Last-Modified 字段信息给服务端，<strong>这时 Etag 的优先级更高</strong>，也就是服务端先会判断 Etag 是否变化了，如果 Etag 有变化就不用在判断 Last-Modified 了，如果 Etag 没有变化，然后再看 Last-Modified。</p>
</li>
</ul>
</li>
</ul>
<h4 id="为什么-ETag-的优先级更高？"><a href="#为什么-ETag-的优先级更高？" class="headerlink" title="为什么 ETag 的优先级更高？"></a>为什么 ETag 的优先级更高？</h4><p>这是因为 ETag 主要能解决 Last-Modified 几个比较难以解决的问题</p>
<ol>
<li>在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求；</li>
<li>可能有些文件是在秒级以内修改的，<code>If-Modified-Since</code> 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次；</li>
<li>有些服务器不能精确获取文件的最后修改时间。</li>
</ol>
<p>注意，<strong>协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong>。</p>
<h4 id="当使用-ETag-字段实现的协商缓存的过程："><a href="#当使用-ETag-字段实现的协商缓存的过程：" class="headerlink" title="当使用 ETag 字段实现的协商缓存的过程："></a>当使用 ETag 字段实现的协商缓存的过程：</h4><ul>
<li><p>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；</p>
</li>
<li><p>当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：</p>
<ul>
<li>如果没有过期，则直接使用本地缓存；</li>
<li>如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；</li>
</ul>
</li>
<li><p>服务器再次收到请求后，</p>
<p>会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较</p>
<ul>
<li><strong>如果值相等，则返回 304 Not Modified，不会返回资源</strong>；</li>
<li>如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；</li>
</ul>
</li>
<li><p>如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。</p>
</li>
</ul>
<h2 id="HTTP-和-HTTPS-区别？"><a href="#HTTP-和-HTTPS-区别？" class="headerlink" title="HTTP 和 HTTPS 区别？"></a>HTTP 和 HTTPS 区别？</h2><ul>
<li>端口号 ：HTTP 默认是 80，HTTPS 默认是 443。</li>
<li>URL 前缀 ：HTTP 的 URL 前缀是 http:// ，HTTPS 的 URL 前缀是 https:// 。</li>
<li>安全性和资源消耗：<ul>
<li>HTTP 协议运行在 TCP 上，所有传输内容都是明文，客户端和服务器端都无法验证对方的身份。</li>
<li>HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，对称加密的密钥用服务器方的证书进用了非对称加密。所以HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li>
</ul>
</li>
</ul>
<h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>定义：有一个密钥，可以对一段内容加密，加密后只有用它才能看到原文。</p>
<p>如果通信双方各持有同一个密钥，且没有别人只带，那么这双方的通信安全可以保证，除非密钥被破解。</p>
<p>但是存在问题：这个密钥怎么让通信双方知道，同时不被别人知道。因为在服务器生成密钥传输给客户端的时候有可能被劫持。</p>
<p>这时候就需要非对称加密了。</p>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>定义：有两把密钥，一把叫公钥，一把叫私钥。用公钥加密的内容必须用私钥才能解开，用私钥加密的内容只有公钥能解开。</p>
<p>服务器把公钥明文传给客户端可能会被劫持，服务器向客户端传递的数据可能会被解析，只能保证客户端到服务器的通信安全。假如使用两对非对称密钥可以解决，但太过耗时。</p>
<p>非对称加密比较耗时，对称加密快很多。</p>
<p>所以 https 采用 非对称加密+对称加密，且非对称加密解密只使用一次就可以。</p>
<ul>
<li>服务器用于<strong>非对称加密</strong>的公钥 A、私钥 AA</li>
<li>浏览器向服务器请求，服务器把公钥 A 明文发给浏览器</li>
<li>浏览器随机生成一个对称加密密钥 B，用公钥 A 加密后传给服务器</li>
<li>服务器用私钥 AA 解密得到密钥 B</li>
<li>这样双方都拥有对称密钥 B 了，且别人无法知道它</li>
</ul>
<p>这样还是存在漏洞，例如中间人攻击</p>
<h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><ul>
<li>服务器用于非对称公钥 A、私钥 AA，将公钥 A 明文发给浏览器</li>
<li>中间人劫持<strong>公钥 A</strong>，将自己的<strong>公钥 X</strong>替换数据包里面的 A 发给浏览器。当然，中间人有<strong>私钥 XX</strong></li>
<li>浏览器随机生成一个对称加密密钥 B，用公钥 X 加密传回服务器</li>
<li>中间人劫持后用私钥 XX 解密得到<strong>密钥 B</strong>，再用公钥 A 加密后传给服务器。</li>
<li>服务器拿到后用私钥 AA 解密得到密钥 B</li>
</ul>
<p>最后结果是：</p>
<ul>
<li>服务器：公钥 A、私钥 AA、公钥 B</li>
<li>中间人：公钥 A、自己的公钥 X 私钥 XX、公钥 B</li>
<li>浏览器：中间人的公钥 X、自己生成的公钥 B</li>
</ul>
<p>这样在服务器浏览器双方都不发现异常的情况下，中间人得到了密钥 B。</p>
<p>原因是：浏览器无法确定自己收到的公钥是不是网站自己的。需要给网站服务器颁发一个“身份证”，也就是 CA 证书。</p>
<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>证书：证书持有者，证书持有者的公钥。</p>
<p>服务器把证书传输给浏览器，浏览器从证书里取公钥。</p>
<p>需要做的是，证书的传输过程中，如何防止被修改。使用数字签名。</p>
<p>把证书内容生成一份签名，比对证书内容和签名是否一致就能察觉是否被修改。</p>
<h2 id="HTTPS-解决了-HTTP-的哪些问题？"><a href="#HTTPS-解决了-HTTP-的哪些问题？" class="headerlink" title="HTTPS 解决了 HTTP 的哪些问题？"></a>HTTPS 解决了 HTTP 的哪些问题？</h2><ul>
<li><p>HTTP 由于是明文传输，所以安全上存在</p>
<ul>
<li><p><strong>窃听风险</strong>，比如通信链路上可以获取通信内容。</p>
</li>
<li><p><strong>篡改风险</strong>，比如强制植入垃圾广告。</p>
</li>
<li><p><strong>冒充风险</strong>，比如冒充淘宝网站。</p>
</li>
</ul>
</li>
<li><p>HTTPS 在 HTTP 与 TCP 层之间加入了 <code>SSL/TLS</code> 协议</p>
<ul>
<li><strong>信息加密</strong>：交互信息无法被窃取。<strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</li>
<li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示。<strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li>
<li><strong>身份证书</strong>：将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</li>
</ul>
</li>
</ul>
<h3 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h3><ul>
<li><p>HTTPS 采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式：</p>
<ul>
<li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</li>
<li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li>
</ul>
<p>采用「混合加密」的方式的原因：</p>
<ul>
<li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li>
<li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li>
</ul>
</li>
</ul>
<h3 id="HTTP-1-0-和-HTTP-1-1-有什么区别？"><a href="#HTTP-1-0-和-HTTP-1-1-有什么区别？" class="headerlink" title="HTTP 1.0 和 HTTP 1.1 有什么区别？"></a>HTTP 1.0 和 HTTP 1.1 有什么区别？</h3><ul>
<li>连接方式：HTTP 1.0 为短连接，HTTP 1.1 支持长连接。</li>
<li>状态响应码：HTTP/1.1中新加入大量状态码。</li>
<li>缓存处理 : 在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, IfNone-Match 等更多可供选择的缓存头来控制缓存策略。</li>
<li>带宽优化及网络连接的使用：HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个 对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content）， 这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li>Host头处理 : HTTP/1.1在请求头中加入了 Host 字段。</li>
</ul>
<h3 id="HTTP-1-1-的优点、缺点和性能"><a href="#HTTP-1-1-的优点、缺点和性能" class="headerlink" title="HTTP/1.1 的优点、缺点和性能"></a>HTTP/1.1 的优点、缺点和性能</h3><ul>
<li><p>优点</p>
<ul>
<li><p>简单：HTTP 基本的报文格式就是 <code>header + body</code>，头部信息也是 <code>key-value</code> 简单文本的形式。</p>
</li>
<li><p>灵活、易于扩展：HTTP 协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员<strong>自定义和扩充</strong>。</p>
<ul>
<li><p>同时 HTTP 由于是工作在应用层（ <code>OSI</code> 第七层），则它<strong>下层可以随意变化</strong>，比如：</p>
<ul>
<li><p>HTTPS 就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层；</p>
</li>
<li><p>HTTP/1.1 和 HTTP/2.0 传输协议使用的是 TCP 协议，而到了 HTTP/3.0 传输协议改用了 UDP 协议。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>应用广泛和跨平台：台式机的浏览器到手机上的各种 APP都是HTTP 的应用，而且天然有<strong>跨平台</strong>的优越性。</p>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>无状态<ul>
<li><strong>好处</strong>，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。</li>
<li>无状态的<strong>坏处</strong>，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。例如登录-&gt;添加购物车-&gt;下单-&gt;结算-&gt;支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。</li>
<li>解决方法：<code>Cookie</code> ：通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</li>
</ul>
</li>
<li>明文传输<ul>
<li>在传输过程中的信息方便阅读，比如 Wireshark 抓包都可以直接肉眼查看，为调试工作带了极大的便利。</li>
<li>信息内容没有隐私，很容易被窃取。</li>
</ul>
</li>
</ul>
</li>
<li><p>性能</p>
<ul>
<li><p>HTTP 协议是基于 <strong>TCP/IP</strong>，并且使用了「<strong>请求 - 应答</strong>」的通信模式，所以性能的关键就在这<strong>两点</strong>里。</p>
<p><em>1. 长连接</em></p>
<p>早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。</p>
<p>为了解决上述 TCP 连接问题，HTTP/1.1 提出了<strong>长连接</strong>的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p>
<p>持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p>
</li>
</ul>
</li>
</ul>
<h3 id="HTTP-是不保存状态的协议-如何保存用户状态"><a href="#HTTP-是不保存状态的协议-如何保存用户状态" class="headerlink" title="HTTP 是不保存状态的协议, 如何保存用户状态?"></a>HTTP 是不保存状态的协议, 如何保存用户状态?</h3><ul>
<li>HTTP 是⼀种不保存状态，即无状态（stateless）协议。保存用户状态需要用到Session 机制。Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（⼀般情况下，服务器会在⼀定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。</li>
<li>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，大部分情况下，客户端通过在 Cookie 中附加⼀个 Session ID来跟踪。</li>
<li>Cookie 被禁用怎么办? 最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。</li>
</ul>
<h3 id="URI-和-URL-的区别是什么"><a href="#URI-和-URL-的区别是什么" class="headerlink" title="URI 和 URL 的区别是什么?"></a>URI 和 URL 的区别是什么?</h3><ul>
<li>URI(Uniform Resource Identifier) 是统⼀资源标志符，可以唯⼀标识⼀个资源。</li>
<li>URL(Uniform Resource Locator) 是统⼀资源定位符，可以提供该资源的路径。</li>
</ul>
<p>它是⼀种具体的 URI，即 URL 可以⽤来标识⼀个资源，⽽且还指明了如何 locate 这个资源。 URI 的作⽤像身份证号⼀样，URL 的作⽤更像家庭住址⼀样。URL 是⼀种具体的 URI，它不仅唯⼀ 标识资源，⽽且还提供了定位该资源的信息。</p>
<h3 id="GET和POST请求的区别？"><a href="#GET和POST请求的区别？" class="headerlink" title="GET和POST请求的区别？"></a>GET和POST请求的区别？</h3><p>GET和POST是HTTP协议的两种请求方式，主要区别是：</p>
<p><img src="https://pic4.zhimg.com/80/v2-ba440cf5ee0d73bf605fb3a6aeee49f7_720w.webp" alt="https://pic4.zhimg.com/80/v2-ba440cf5ee0d73bf605fb3a6aeee49f7_720w.webp" loading="lazy"></p>
<p>最大的区别是，请求带参数时，报文格式不同，GET方法的参数放在URL中，POST方法的参数放在请求体中。不带参数的请求，没有区别。</p>
<h3 id="TCP粘包问题"><a href="#TCP粘包问题" class="headerlink" title="TCP粘包问题"></a>TCP粘包问题</h3><ul>
<li>tcp粘包：就是指发送方发送的若干数据到接收方时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包的数据的尾</li>
<li>本质产生原因：tcp协议是面向字节流的，应用层协议没有定义消息的边界导致数据的接收方无法拼接数据</li>
<li>产生情况：</li>
<li>tcp连接复用造成的粘包问题 Nagle算法导致的粘包问题 数据包过大导致的粘包问题 流量控制、拥塞控制也可能导致粘包 接收方不及时接收缓冲区的包，造成多个包接收 解决方法：</li>
<li>发送方解决，关闭Nagle算法 应用层解决，尾部添加结束标记；发送数据定长</li>
</ul>
<h3 id="长连接、短连接"><a href="#长连接、短连接" class="headerlink" title="长连接、短连接"></a>长连接、短连接</h3><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。 而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。 HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p>
<h3 id="简述SYN攻击"><a href="#简述SYN攻击" class="headerlink" title="简述SYN攻击"></a>简述SYN攻击</h3><p>SYN攻击即利用TCP协议缺陷，通过发送大量的半连接请求，占用半连接队列，耗费CPU和内存资源。</p>
<p>优化方式：</p>
<ol>
<li>缩短SYN Timeout时间</li>
<li>记录IP，若连续受到某个IP的重复SYN报文，从这个IP地址来的包会被一概丢弃。</li>
</ol>
<p>MSL即报文最大生存时间。设置2MSL可以保证上一次连接的报文已经在网络中消失，不会出现与新TCP连接报文冲突的情况。</p>
<h3 id="转发和重定向的区别"><a href="#转发和重定向的区别" class="headerlink" title="转发和重定向的区别"></a>转发和重定向的区别</h3><p>转发是服务器行为。服务器直接向目标地址访问URL,将相应内容读取之后发给浏览器，用户浏览器地址栏URL不变，转发页面和转发到的页面可以共享request里面的数据。</p>
<p>重定向是利用服务器返回的状态码来实现的，如果服务器返回301或者302，浏览器收到新的消息后自动跳转到新的网址重新请求资源。用户的地址栏url会发生改变，而且不能共享数据。</p>
<h3 id="简述http2-0的改进"><a href="#简述http2-0的改进" class="headerlink" title="简述http2.0的改进"></a>简述http2.0的改进</h3><p>提出多路复用。多路复用前，文件时串行传输的，请求a文件，b文件只能等待，并且连接数过多。引入多路复用，a文件b文件可以同时传输。</p>
<p>引入了二进制数据帧。其中帧对数据进行顺序标识，有了序列id，服务器就可以进行并行传输数据。</p>
<h3 id="Get方法参数有大小限制吗"><a href="#Get方法参数有大小限制吗" class="headerlink" title="Get方法参数有大小限制吗"></a>Get方法参数有大小限制吗</h3><p>一般HTTP协议里并不限制参数大小限制。但一般由于get请求是直接附加到地址栏里面的，由于浏览器地址栏有长度限制，因此使GET请求在浏览器实现层面上看会有长度限制。</p>
<h3 id="为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态？"><a href="#为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态？" class="headerlink" title="为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？"></a>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</h3><p>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p>
<h3 id="如何对http1进行优化？"><a href="#如何对http1进行优化？" class="headerlink" title="如何对http1进行优化？"></a>如何对http1进行优化？</h3><ul>
<li>第⼀个思路是，通过缓存技术来避免发送 HTTP 请求。客户端收到第⼀个请求的响应后，可以将其缓存在本地磁盘，下次请求的时候，如果缓存没过期，就直接读取本地缓存的响应数据。如果缓存过期，客户端发送请求的时候带上响应数据的摘要，服务器⽐对后发现资源没有变化，就发出不带包体的 304 响应，告诉客户端缓存的响应仍然有效。</li>
<li>第⼆个思路是，减少 HTTP 请求的次数，有以下的⽅法：<ol>
<li>将原本由客户端处理的 定向请求，交给代理服务器处理，这样可以减少 定向请求的次数；</li>
<li>将多个⼩资源合并成⼀个⼤资源再传输，能够减少 HTTP 请求次数以及 头部的 复传输，再来减少 TCP 连 接数 ，进⽽省去 TCP 握⼿和慢启动的⽹络消耗；</li>
<li>按需访问资源，只访问当前⽤户看得到/⽤得到的资源，当客户往下滑动，再访问接下来的资源，以此达到延 迟请求，也就减少了同⼀时间的 HTTP 请求次数。</li>
</ol>
</li>
<li>第三思路是，通过压缩响应资源，降低传输资源的⼤⼩，从⽽提⾼传输效率，所以应当选择更优秀的压缩算法。</li>
</ul>
<h3 id="TLS-协议是如何解决-HTTP-的⻛险的呢？"><a href="#TLS-协议是如何解决-HTTP-的⻛险的呢？" class="headerlink" title="TLS 协议是如何解决 HTTP 的⻛险的呢？"></a>TLS 协议是如何解决 HTTP 的⻛险的呢？</h3><p>信息加密： HTTP 交互信息是被加密的，第三⽅就⽆法被窃取； 校验机制：校验信息传输过程中是否有被第三⽅篡改过，如果被篡改过，则会有警告提示； 身份证书：证明淘宝是真的淘宝⽹；</p>
<h3 id="http2优点："><a href="#http2优点：" class="headerlink" title="http2优点："></a>http2优点：</h3><ol>
<li><p>第⼀点，对于常⻅的 HTTP 头部通过静态表和 Huffman 编码的⽅式，将体积压缩了近⼀半，⽽且针对后续的请求头部，还可以建⽴动态表，将体积压缩近 90%，⼤⼤提⾼了编码效率，同时节约了带宽资源。不过，动态表并⾮可以⽆限增⼤， 因为动态表是会占⽤内存的，动态表越⼤，内存也越⼤，容易影响服务器总体的并发能⼒，因此服务器需要限制 HTTP/2 连接时⻓或者请求次数。</p>
</li>
<li><p>HTTP/2 实现了 Stream 并发，多个 Stream 只需复⽤ 1 个 TCP 连接，节约了 TCP 和 TLS 握⼿时间，以及减少了 TCP 慢启动阶段对流 的影响。不同的 Stream ID 才可以并发，即时乱序发送帧也没问题，但是同⼀个</p>
<p>Stream ⾥的帧必须严格有序。另外，可以根据资源的渲染顺序来设置 Stream 的优先级，从⽽提⾼⽤户体验。</p>
</li>
<li><p>服务器⽀持主动推送资源，⼤⼤提升了消息的传输性能，服务器推送资源时，会先发送 PUSH_PROMISE帧，告诉客户端接下来在哪个 Stream 发送资源，然后⽤偶数号 Stream 发送资源给客户端。</p>
</li>
</ol>
<h3 id="http2-缺点和http3-的改进"><a href="#http2-缺点和http3-的改进" class="headerlink" title="http2 缺点和http3 的改进"></a>http2 缺点和http3 的改进</h3><p>HTTP/2 虽然具有多个流并发传输的能⼒，但是传输层是 TCP 协议，于是存在以下缺陷：</p>
<ul>
<li>队头阻塞，HTTP/2 多个请求跑在⼀个 TCP 连接中，如果序列号较低的 TCP 段在⽹络传输中丢失了，即使序列号较⾼的 TCP 段已经被接收了，应⽤层也⽆法从内核中读取到这部分数据，从 HTTP 视⻆看，就是多个请求被阻塞了；</li>
<li>TCP 和 TLS 握⼿时延，TCL 三次握⼿和 TLS 四次握⼿，共有 3-RTT 的时延；</li>
<li>连接迁移需要重新连接，移动设备从 4G ⽹络环境切换到 WIFI 时，由于 TCP 是基于四元组来确认⼀条 TCP连接的，那么⽹络环境变化后，就会导致 IP 地址或端⼝变化，于是 TCP 只能断开连接，然后再 新建⽴连接，切换⽹络环境的成本⾼；</li>
</ul>
<p>HTTP/3 就将传输层从 TCP 替换成了 UDP，并在 UDP 协议上开发了 QUIC 协议，来保证数据的可靠传输。 QUIC 协议的特点：</p>
<ul>
<li>⽆队头阻塞，QUIC 连接上的多个 Stream 之间并没有依赖，都是独⽴的，也不会有底层协议限制，某个流发⽣丢包了，只会影响该流，其他流不受影响；</li>
<li>建⽴连接速度快，因为 QUIC 内部包含 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建⽴连接与 TLS 密钥协商，甚⾄在第⼆次连接的时候，应⽤数据包可以和 QUIC 握⼿信息（连接信息 + TLS 信息）⼀起发送，达到 0-RTT 的效果。</li>
<li>连接迁移，QUIC 协议没有⽤四元组的⽅式来“绑定”连接，⽽是通过「连接 ID 」来标记通信的两个端点，客户端和服务器可以各⾃选择⼀组 ID 来标记⾃⼰，因此即使移动设备的⽹络变化后，导致 IP 地址变化了，只要仍保有上下⽂信息（⽐如连接 ID、TLS 密钥等），就可以“⽆缝”地复⽤原连接，消除 连的成本；</li>
</ul>
<p>另外 HTTP/3 的 QPACK 通过两个特殊的单向流来同步双⽅的动态表，解决了 HTTP/2 的 HPACK 队头阻塞问题。</p>
<h3 id="什么是-SYN-攻击？如何避免-SYN-攻击？"><a href="#什么是-SYN-攻击？如何避免-SYN-攻击？" class="headerlink" title="什么是 SYN 攻击？如何避免 SYN 攻击？"></a>什么是 SYN 攻击？如何避免 SYN 攻击？</h3><ul>
<li>SYN 攻击：TCP 连接建⽴是需要三次握⼿，假设攻击者短时间伪造不同 IP 地址的 SYN 报⽂，服务端每接收到⼀个 SYN 报⽂，就进⼊ SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报⽂，⽆法得到未知 IP 主机的ACK 应答，久⽽久之就会占满服务端的 SYN 接收队列（未连接队列），使得服务器不能为正常⽤户服务。</li>
</ul>
<h3 id="为什么需要-TIME-WAIT-状态？"><a href="#为什么需要-TIME-WAIT-状态？" class="headerlink" title="为什么需要 TIME_WAIT 状态？"></a>为什么需要 TIME_WAIT 状态？</h3><p>主动发起关闭连接的⼀⽅，才会有 TIME-WAIT 状态。需要 TIME-WAIT 状态，主要是两个原因：</p>
<ul>
<li>防⽌具有相同「四元组」的「旧」数据包被收到；</li>
<li>保证「被动关闭连接」的⼀⽅能被正确的关闭，即保证最后的 ACK 能让被动关闭⽅接收，从⽽帮助其正常关闭；</li>
</ul>
<h3 id="TIME-WAIT-过多有什么危害？"><a href="#TIME-WAIT-过多有什么危害？" class="headerlink" title="TIME_WAIT 过多有什么危害？"></a>TIME_WAIT 过多有什么危害？</h3><h2 id="地址栏输入url到页面呈现的过程"><a href="#地址栏输入url到页面呈现的过程" class="headerlink" title="地址栏输入url到页面呈现的过程"></a>地址栏输入url到页面呈现的过程</h2><ul>
<li>将 url 解析成 ip 地址。先查找缓存，没有则进行 dns 解析，向域名服务器处获取 ip</li>
<li>建立 tcp 连接，ssl 有一个验证的过程</li>
<li>发送 http 请求</li>
<li>收到服务器响应的资源文档</li>
<li>构建 dom 树和 cssom 树，布局，再渲染</li>
<li>画面呈现</li>
</ul>
<h2 id="ajax、Fetch-与-axios"><a href="#ajax、Fetch-与-axios" class="headerlink" title="ajax、Fetch 与 axios"></a>ajax、Fetch 与 axios</h2><h3 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h3><ul>
<li><p>使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> 实现</p>
</li>
<li><p>特点：</p>
<ul>
<li><p>会遇到 XSS、CSRF 攻击</p>
</li>
<li><p>本身是针对 MVC 的编程</p>
</li>
<li><p>基于原生的 XHR 开发，XHR 本身的架构不清晰，有了 fetch 的替代方案。</p>
</li>
</ul>
</li>
</ul>
<h3 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h3><ul>
<li><p>XHR 的替代，ES6 出现的，使用了 ES6 中的 promise 对象，由 js 原生提供，没有使用 XMLHttpRequest 对象</p>
</li>
<li><p>特点：</p>
<ul>
<li><p>符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里</p>
</li>
<li><p>更好更方便的写法</p>
</li>
<li><p>更加底层，提供的 API 丰富（request, response）</p>
</li>
<li><p>脱离了 XHR，是 ES 规范里新的实现方式</p>
</li>
<li><p>fetchtch 只对网络请求报错，对 400，500 都当做成功的请求，需要封装去处理</p>
</li>
<li><p>fetch 默认不会带 cookie，需要添加配置项</p>
</li>
<li><p>fetch 不支持 abort，不支持超时控制，使用 setTimeout 及 Promise.reject 的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费</p>
</li>
<li><p>fetch 没有办法原生监测请求的进度，而 XHR 可以。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">    <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data), <span class="comment">// must match &#x27;Content-Type&#x27; header</span></span><br><span class="line">    <span class="attr">cache</span>: <span class="string">&#x27;no-cache&#x27;</span>, <span class="comment">// *default, no-cache, reload, force-cache, only-if-cached</span></span><br><span class="line">    <span class="attr">credentials</span>: <span class="string">&#x27;same-origin&#x27;</span>, <span class="comment">// include, same-origin, *omit</span></span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/4.0 MDN Example&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="comment">// *GET, POST, PUT, DELETE, etc.</span></span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;cors&#x27;</span>, <span class="comment">// no-cors, cors, *same-origin</span></span><br><span class="line">    <span class="attr">redirect</span>: <span class="string">&#x27;follow&#x27;</span>, <span class="comment">// manual, *follow, error</span></span><br><span class="line">    <span class="attr">referrer</span>: <span class="string">&#x27;no-referrer&#x27;</span>, <span class="comment">// *client, no-referrer</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>()) <span class="comment">// parses response to JSON</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><p>axios 是一个基于 Promise 的用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生 XHR 的封装，只不过它是 Promise 的实现版本，符合最新的 ES 规范。</p>
<ul>
<li>支持 Promise API。</li>
<li>提供了一些并发请求的接口（重要，方便了很多的操作）。</li>
<li>在浏览器中创建 XMLHttpRequests。在 node.js 则创建 http 请求。（自动性强）</li>
<li>支持拦截请求和响应。</li>
<li>自动转换 JSON 数据。</li>
<li>客户端支持防御 CSRF、 XSRF。</li>
</ul>
<h3 id="Fetch-与-Ajax-的不同"><a href="#Fetch-与-Ajax-的不同" class="headerlink" title="Fetch 与 Ajax 的不同"></a>Fetch 与 Ajax 的不同</h3><ul>
<li>当接收到一个代表错误的 HTTP 状态码时，从 <code>fetch()</code> 返回的 Promise 不会被标记为 reject，而是标记为 resolve （返回值的 <code>ok</code> 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。</li>
<li><code>fetch()</code> <strong>可以接受跨域 cookies；</strong>你也可以使用 <code>fetch()</code> 建立起跨域会话。</li>
<li><code>fetch</code> <strong>不会发送 cookies</strong>。除非你使用了<em>credentials</em> 的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters">初始化选项</a>。</li>
</ul>
<h3 id="fetch-发送-2-次请求的原因"><a href="#fetch-发送-2-次请求的原因" class="headerlink" title="fetch 发送 2 次请求的原因"></a>fetch 发送 2 次请求的原因</h3><p>用 fetch 的 post 请求时，第一次发送了一个 Options 请求，询问服务器是否支持该类型的请求，如果服务器支持，则在第二次中发送真正的请求。</p>
<h2 id="Cookie-与-Session"><a href="#Cookie-与-Session" class="headerlink" title="Cookie 与 Session"></a>Cookie 与 Session</h2><ul>
<li>由于 http 的无状态性，为了使某个域名下的所有网页能够共享某些数据，session 和 cookie 出现了。</li>
<li>cookie 是用户通行证，存储在客户端，在发送请求时附带。session 里面包含了用户的认证信息和登录状态等信息，保存在服务器端。</li>
</ul>
<h3 id="Cookie-和-Session-共同使用"><a href="#Cookie-和-Session-共同使用" class="headerlink" title="Cookie 和 Session 共同使用"></a>Cookie 和 Session 共同使用</h3><ul>
<li>客户端发一个 http 请求给服务器</li>
<li>服务器接受请求后，建立一个 session，发回 http 响应给客户端，其中的 set-cookie 头部带有 sessionid</li>
<li>客户端收到响应后，后续会自动在请求头中加 cookie</li>
<li>服务器接收请求，分解 cookie，验证成功后将请求返回给客户端。</li>
</ul>
<p>用 session 只需在客户端保存一个 id，大量数据都是保存在服务端，对服务器有压力。</p>
<p>用 cookie 不用 session，那么账户信息全部保存在客户端，一旦被劫持，全部信息都会泄露。并且客户端数据量变大，网络传输的数据量也会变大。</p>
<h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>是一种服务端无状态的认证方式。Token 类似一个令牌，无状态，用户信息都被加密到 token 中，服务器收到 token 后解密就可知道是哪个用户。需要开发者手动添加。</p>
<p>token 在客户端一般存放于 localStorage，cookie，或 sessionStorage 中。在服务器一般存于数据库中</p>
<p>token 的认证流程与 cookie 很相似</p>
<ul>
<li>用户登录，成功后服务器返回 Token 给客户端。</li>
<li>客户端收到数据后保存在客户端</li>
<li>客户端再次访问服务器，将 token 放入 headers 中</li>
<li>服务器端采用 filter 过滤器校验。校验成功则返回请求数据，校验失败则返回错误码</li>
</ul>
<h2 id="用-Token不用-Cookie-Session-的优点"><a href="#用-Token不用-Cookie-Session-的优点" class="headerlink" title="用 Token不用 Cookie+Session 的优点"></a>用 Token不用 Cookie+Session 的优点</h2><ul>
<li>避免 CSRF 攻击</li>
</ul>
<p>用户登陆银行网页，同时登陆了危险网页，攻击者在网页放一个表单，该表单提交 src 为<code>http://www.bank.com/api/transfer</code>，body 为<code>count=1000&amp;to=Tom</code>。倘若是 session+cookie，表单发起的 POST 请求不受到浏览器同源策略限制，可以使用其它域的 Cookie 向其它域发送 POST 请求，形成 CSRF 攻击。在 post 请求的瞬间，cookie 会被浏览器自动添加到请求头中。但 token 不同，token 是开发者为了防范 csrf 而特别设计的令牌，浏览器不会自动添加到 headers 里，攻击者也无法访问用户的 token，所以提交的表单无法通过服务器过滤，也就无法形成攻击。</p>
<ul>
<li>Token 是一种服务端无状态的认证方式，而 cookie+session 是有状态的。（ 所谓无状态就是服务端并不会保存身份认证相关的数据。）</li>
</ul>
<h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>头部 +负载+签名</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javascript</span></span><br><span class="line"><span class="keyword">var</span> encodedString = <span class="title function_">base64UrlEncode</span>(header) + <span class="string">&#x27;.&#x27;</span> + <span class="title function_">base64UrlEncode</span>(payload);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> signature = <span class="title class_">HMACSHA256</span>(encodedString, <span class="string">&#x27;secret&#x27;</span>); <span class="comment">// TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ,加盐secret组合加密</span></span><br><span class="line"><span class="comment">// 将这三部分用.连接成一个完整的字符串,构成了最终的jwt:</span></span><br></pre></td></tr></table></figure>

<p>在客户端应用：一般是在请求头里加入<code>Authorization</code>，并加上<code>Bearer</code>标注</p>
<p>流程和 token 的一样</p>
<p>缺点：一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。</p>
<h2 id="cookie-和-token-都存放在-header-中，为什么不会劫持-token？"><a href="#cookie-和-token-都存放在-header-中，为什么不会劫持-token？" class="headerlink" title="cookie 和 token 都存放在 header 中，为什么不会劫持 token？"></a>cookie 和 token 都存放在 header 中，为什么不会劫持 token？</h2><ul>
<li><p>Cookie</p>
<ul>
<li>攻击者通过 xss 拿到用户的 cookie 然后就可以伪造 cookie 了。</li>
<li>通过 csrf 在同个浏览器下面通过浏览器会自动带上 cookie 的特性</li>
<li>在通过 用户网站-攻击者网站-攻击者请求用户网站的方式 浏览器会自动带上 cookie</li>
</ul>
</li>
<li><p>token</p>
<ul>
<li>不会被浏览器带上 问题 2 解决</li>
<li>token 是放在 jwt 里面下发给客户端的 而且不一定存储在哪里 不能通过 document.cookie 直接拿到，通过 jwt+ip 的方式 可</li>
<li>防止 被劫持 即使被劫持 也是无效的 jwt</li>
</ul>
</li>
</ul>
<h2 id="跨页面通信"><a href="#跨页面通信" class="headerlink" title="跨页面通信"></a>跨页面通信</h2><p>同源页面（不在同一个 tab）：可以使用 LocalStorage</p>
<p>非同源页面：iframe、postmessage</p>
<p>H5 之后为 window 新增了 window.postMessage()方法，第一个参数是要发送的数据，第二个参数是域名。</p>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><ul>
<li>postMessage 跨域：可以跨域操作的 window 属性之一。</li>
<li>CORS：服务端设置 Access-Control-Allow-Origin 即可，前端无须设置，若要带 cookie 请求，前后端都需要设置。<ul>
<li><code>Access-Control-Allow-Origin *;</code></li>
<li><code>Access-Control-Allow-Methods &quot;POST, GET, OPTIONS&quot;;</code></li>
<li><code>Access-Control-Allow-Headers &quot;Origin, Authorization, Accept&quot;;</code></li>
<li><code>Access-Control-Allow-Credentials true;</code></li>
</ul>
</li>
<li>代理跨域：启一个代理服务器，实现数据的转发</li>
<li>JSONP：script 标签 src 属性中的链接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。例如：<code>script.src = http://another.com/weather.json?callback=gotWeather;</code>，需要后端配合。</li>
</ul>
<h3 id="查看网站性能"><a href="#查看网站性能" class="headerlink" title="查看网站性能"></a>查看网站性能</h3><p>检测页面加载时间</p>
<ul>
<li>被动检测：在页面设置检测脚本，当用户访问网页时，记录数据，传回数据库分析</li>
<li>主动监测：搭建分布式环境，模拟用户访问页面，主动采集数据并分析</li>
</ul>
<h3 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h3><ul>
<li>降低请求量：合并资源，减少 http 请求数</li>
<li>加快请求速度：预解析 DNS、CDN 分发</li>
<li>使用缓存</li>
<li>加快渲染：加载顺序（js 放最后），SSR，使用 GPU</li>
</ul>
<h3 id="屏幕卡顿"><a href="#屏幕卡顿" class="headerlink" title="屏幕卡顿"></a>屏幕卡顿</h3><p>原因：</p>
<ul>
<li>内存溢出</li>
<li>资源过大</li>
<li>资源加载</li>
<li>canvas 绘制帧率</li>
</ul>
<p>办法：</p>
<ul>
<li>在物体离开屏幕可视区域即回收销毁</li>
<li>选用体积较小的资源，例如图片，可以在近处放清晰度高的，远处放清晰度低的</li>
<li>预加载</li>
<li>大部分显示器刷新频率为 60 次/s，因此游戏的每一帧绘制间隔时间需要小于 1000/60=16.7ms，才能让用户觉得不卡顿</li>
</ul>
<h3 id="js-加载过程阻塞，解决方法"><a href="#js-加载过程阻塞，解决方法" class="headerlink" title="js 加载过程阻塞，解决方法"></a>js 加载过程阻塞，解决方法</h3><ul>
<li>制定 script 标签的 async 属性，异步执行</li>
<li>设置 defer 属性，脚本将在页面完成解析时执行</li>
</ul>
<h1 id="Operation-System"><a href="#Operation-System" class="headerlink" title="Operation System"></a>Operation System</h1><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><ul>
<li>进程：系统调用资源的最小单位，也就是说是拥有资源且独立运行的最小单位。</li>
<li>线程：CPU 调度的最小单位。一个进程可以拥有多个线程，线程是可以独立运行的最小单位。</li>
</ul>
<h2 id="进程切换开销"><a href="#进程切换开销" class="headerlink" title="进程切换开销"></a>进程切换开销</h2><ol>
<li>切换虚拟地址空间</li>
<li>切换 CPU 上下文</li>
<li>切换内核栈</li>
</ol>
<h2 id="线程切换开销"><a href="#线程切换开销" class="headerlink" title="线程切换开销"></a>线程切换开销</h2><ol>
<li>切换 CPU 上下文</li>
<li>切换内核栈</li>
</ol>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><ul>
<li>管道</li>
<li>消息队列</li>
<li>信号量</li>
<li>信号</li>
<li>套接字 socket</li>
<li>共享内存</li>
</ul>
</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="Donate" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><span class="icon iconify" data-icon="ri:hand-coin-line"></span></span><div id="reward-comment">I'm so cute. Please give me money.</div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>Aria</li><li class="post-copyright-link"><strong>Post link: </strong><a href="https://aria-geng.github.io/_myBlog/2023/04/30/CN|Browser|OS/" title="Computer Network|Browser|OS">https://aria-geng.github.io/_myBlog/2023/04/30/CN|Browser|OS/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> unless otherwise stated.</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/_myBlog/2023/04/30/Vue/" rel="prev" title="Vue"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">Vue</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/_myBlog/2023/04/30/JavaScript%7CTypeScript/" rel="next" title="JavaScript|TypeScript"><span class="post-nav-text">JavaScript|TypeScript</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2023 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> Aria</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v5.4.2</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.9</span></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></body></html>